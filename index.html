<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rami en ligne - Jeu de cartes multijoueur</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Poppins:wght@600&display=swap" />
  <style>
    /* Variables CSS modernes pour le jeu Rami */
    :root {
      --primary: #2c3e50;
      --secondary: #3498db;
      --accent: #e74c3c;
      --success: #27ae60;
      --warning: #f39c12;
      --danger: #e74c3c;
      --text: #2d3436;
      --text-light: #7f8c8d;
      --text-white: #ffffff;
      --bg: #f8f9fa;
      --bg-dark: #1a1a1a;
      --felt-green: #0d5016;
      --felt-green-light: #1a7a28;
      --card-white: #ffffff;
      --card-red: #e74c3c;
      --card-black: #2c3e50;
      --shadow-sm: 0 2px 8px rgba(0,0,0,0.1);
      --shadow-md: 0 4px 16px rgba(0,0,0,0.15);
      --shadow-lg: 0 8px 32px rgba(0,0,0,0.2);
      --shadow-xl: 0 16px 64px rgba(0,0,0,0.25);
      --shadow-glow: 0 0 20px rgba(52,152,219,0.3);
      --radius: 12px;
      --radius-sm: 8px;
      --radius-lg: 16px;
      --transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
      --transition-bounce: all 0.4s cubic-bezier(0.68,-0.55,0.265,1.55);
      --card-width: 140px;
      --card-height: 210px;
      --hand-bottom: 40px;
      --chat-width: 320px;
      --chat-height: 280px;
      --gradient-primary: linear-gradient(135deg,#3498db 0%,#2980b9 100%);
      --gradient-success: linear-gradient(135deg,#27ae60 0%,#229954 100%);
      --gradient-felt: linear-gradient(135deg,#0d5016 0%,#1a7a28 50%,#0d5016 100%);
    }
    
    .no-click { 
      pointer-events: none; 
      opacity: 0.6; 
    }
    
    /* Reset et base */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: manipulation;
    }

    body {
      font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: var(--text);
      line-height: 1.6;
      min-height: 100vh;
      overflow-x: hidden;
      background: var(--felt-green);
      background-image: var(--gradient-felt);
    }

    #game {
      display: none;
      flex-direction: column;
      height: 100vh;
    }

    /* Menu principal */
    .menu-overlay {
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.6s ease-out;
      padding: 1rem;
    }

    .menu-content {
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      padding: 2rem;
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-xl);
      text-align: center;
      max-width: min(500px, 90vw);
      width: 100%;
      border: 1px solid rgba(255,255,255,0.2);
      animation: slideUp 0.6s ease-out;
    }

    .menu-content h1 {
      font-family: 'Poppins', sans-serif;
      font-size: clamp(2rem, 5vw, 2.5rem);
      color: var(--primary);
      margin-bottom: 1.5rem;
      text-shadow: 0 2px 10px rgba(0,0,0,0.1);
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .menu-section {
      margin: 1.5rem 0;
    }

    .menu-section h2 {
      font-size: clamp(1.1rem, 3vw, 1.3rem);
      color: var(--text);
      margin-bottom: 0.75rem;
      font-weight: 500;
    }

    .separator {
      margin: 1.5rem 0;
      position: relative;
      color: var(--text-light);
      font-weight: 500;
      background: rgba(255,255,255,0.95);
      padding: 0 1rem;
      display: inline-block;
    }

    .separator::before {
      content: '';
      position: absolute;
      top: 50%;
      left: -30px;
      right: -30px;
      height: 1px;
      background: linear-gradient(to right, transparent, var(--text-light), transparent);
      z-index: -1;
    }

    .join-form {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .room-input {
      flex: 1;
      min-width: 200px;
      padding: 0.75rem 1rem;
      border: 2px solid #e0e0e0;
      border-radius: var(--radius);
      font-size: 1rem;
      transition: var(--transition);
      background: rgba(255,255,255,0.9);
      backdrop-filter: blur(10px);
    }

    .room-input:focus {
      outline: 2px solid var(--secondary);
      outline-offset: 2px;
      box-shadow: 0 0 0 3px rgba(52,152,219,0.1);
      transform: scale(1.02);
    }

    /* Boutons */
    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: var(--radius);
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition-bounce);
      position: relative;
      overflow: hidden;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      width: 100%;
      max-width: 300px;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(255,255,255,0.3);
      border-radius: 50%;
      transform: translate(-50%,-50%);
      transition: width 0.6s, height 0.6s;
    }

    .btn:hover::before {
      width: 300px;
      height: 300px;
    }

    .btn-primary {
      background: var(--gradient-primary);
      color: var(--text-white);
      box-shadow: var(--shadow-md);
    }

    .btn-primary:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg), var(--shadow-glow);
    }

    .btn-secondary {
      background: var(--gradient-success);
      color: var(--text-white);
      box-shadow: var(--shadow-md);
    }

    .btn-secondary:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .btn-secondary:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg), 0 0 20px rgba(39,174,96,0.3);
    }

    .btn:disabled {
      background: #bdc3c7;
      cursor: not-allowed;
      box-shadow: none;
    }

    /* Game layout */
    /* Header du jeu */
    .game-header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(10px);
      z-index: 100;
      color: white;
    }

    .header-left, .header-right {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    /* Pour ne pas masquer le contenu sous le header fixe */
    .game-play-area {
      padding-top: 60px;
      height: calc(100vh - 60px);
      display: flex;
      flex-direction: column;
      position: relative;
    }

    /* Nouvelle disposition du plateau de jeu */
    .game-table-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
      padding: 20px;
    }

    /* Zone centrale - Pioche seule */
    .table-center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    /* Joker en haut √† gauche */
    #joker {
      position: fixed;
      top: 70px;
      left: 20px;
      z-index: 200;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    .joker-label {
      color: var(--text-white);
      font-weight: 600;
      font-size: 1rem;
      text-align: center;
      background: rgba(0,0,0,0.3);
      padding: 0.5rem;
      border-radius: var(--radius);
      backdrop-filter: blur(10px);
    }

    /* Deck et d√©fausse */
    .deck-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
    }

    .deck-pile {
      position: relative;
      cursor: pointer;
      transition: var(--transition);
    }

    .deck-pile:hover {
      transform: translateY(-5px);
      filter: brightness(1.1);
    }

    .deck-pile.clickable {
      cursor: pointer;
    }

    .deck-label {
      color: var(--text-white);
      font-weight: 600;
      font-size: clamp(1rem, 2.5vw, 1.2rem);
      text-align: center;
      background: rgba(0,0,0,0.3);
      padding: 0.75rem 1.25rem;
      border-radius: var(--radius);
      backdrop-filter: blur(10px);
    }

    /* Cartes */
    .card {
      width: var(--card-width);
      height: var(--card-height);
      border-radius: var(--radius-sm);
      box-shadow: var(--shadow-md);
      position: relative;
      cursor: pointer;
      transition: var(--transition);
      border: 1px solid #e0e0e0;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 0.75rem;
      font-weight: 700;
      user-select: none;
      background: var(--card-white);
    }

    .card:hover {
      transform: translateY(-8px);
      box-shadow: var(--shadow-lg);
      z-index: 10;
    }

    .card.back {
      background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 50%, #1e3a8a 100%);
      border: 2px solid #1e40af;
    }

    .card.back::before {
      content: 'üÇ†';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 3.5rem;
      color: white;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    .corner {
      font-size: 1.2rem;
      line-height: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: var(--card-black);
    }

    .corner.top {
      align-self: flex-start;
    }

    .corner.bottom {
      align-self: flex-end;
      transform: rotate(180deg);
    }

    .card.red .corner {
      color: var(--card-red);
    }

    .suit.main {
      font-size: 6rem;
      line-height: 1;
      text-align: center;
      flex-grow: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--card-black);
    }

    .card.red .suit.main {
      color: var(--card-red);
    }

    /* Liste des joueurs */
    #players-container {
      display: flex;
      justify-content: space-around;
      padding: 20px;
      flex-wrap: wrap;
      gap: 20px;
      z-index: 30;
      position: relative;
    }

    .player-slot {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      min-width: 180px;
      position: relative;
    }

    .player-info {
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      padding: 0.75rem 1rem;
      border-radius: var(--radius);
      color: var(--text-white);
      font-weight: 500;
      border: 1px solid rgba(255,255,255,0.2);
      min-width: 150px;
      text-align: center;
      font-size: clamp(1rem, 2.5vw, 1.1rem);
      transition: var(--transition);
    }

    .player-info.active {
      background: rgba(52,152,219,0.3);
      border-color: rgba(52,152,219,0.5);
      box-shadow: var(--shadow-glow);
      transform: scale(1.05);
    }

    .player-name {
      font-weight: 600;
      margin-bottom: 5px;
      font-size: 1.1em;
    }

    .player-hand-count {
      font-size: 0.9em;
      opacity: 0.9;
    }

    /* Zone de d√©fausse sous chaque joueur - MODIFI√â */
    .player-discard {
      min-height: 50px;
      min-width: 100px;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-top: 10px;
      position: relative;
      z-index: 10;
    }

    .player-discard .card {
      width: 80px;
      height: 120px;
      cursor: pointer;
      position: relative;
      z-index: 10;
    }

    /* Style sp√©cial pour la d√©fausse du joueur pr√©c√©dent */
    .player-discard.previous {
      border: 2px dashed rgba(52, 152, 219, 0.6);
      border-radius: var(--radius-sm);
      padding: 5px;
      box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
      z-index: 15;
    }

    .player-discard.previous .card {
      transform: scale(1.1);
      box-shadow: 0 0 15px rgba(52, 152, 219, 0.5);
    }

    /* Main du joueur */
    #hand-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: auto;
      z-index: 100;
      background: transparent;
      padding: 10px;
    }

    #hand {
      display: flex;
      justify-content: center;
      gap: 0;
      padding: 0;
      min-width: content;
      width: fit-content;
      margin: 0 auto;
      position: relative;
      min-height: var(--card-height);
    }

    #hand .card {
      margin-right: -80px; /* Chevauchement des cartes */
      transition: var(--transition);
      cursor: grab;
      position: relative;
    }

    #hand .card:last-child {
      margin-right: 0;
      z-index: 5;
    }

    #hand .card:hover {
      z-index: 10;
      transform: translateY(-15px);
    }

    #hand .card.sortable-ghost {
      opacity: 0.2;
    }
     .player-discard .card.clickable {
  cursor: pointer;
  border: 2px solid #00ff00;
  transition: transform 0.2s;
}
.player-discard .card.clickable:hover {
  transform: scale(1.05);
}
    /* Contr√¥les du jeu */
    .game-controls {
      position: fixed;
      top: 70px;
      right: 20px;
      width: 240px;
      padding: 1rem;
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(10px);
      border-radius: var(--radius);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      z-index: 40;
      overflow-y: auto;
    }

    .btn-special {
      padding: 0.75rem;
      background: var(--gradient-primary);
      color: var(--text-white);
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      font-weight: 500;
      transition: var(--transition);
      text-transform: uppercase;
      font-size: clamp(0.9rem, 2vw, 1rem);
    }

    .btn-special:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .btn-special:disabled {
      background: #6c757d;
      cursor: not-allowed;
      opacity: 0.6;
    }

    .btn-action {
      padding: 0.75rem;
      background: var(--gradient-success);
      color: var(--text-white);
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      font-weight: 600;
      transition: var(--transition);
      text-transform: uppercase;
      font-size: clamp(1rem, 2.5vw, 1.1rem);
      margin-top: auto;
    }

    .btn-action:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .btn-action:disabled {
      background: #6c757d;
      cursor: not-allowed;
      opacity: 0.6;
    }

    /* Modals */
    .modal {
      position: fixed;
      z-index: 10000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(5px);
      animation: fadeIn 0.3s ease-out;
    }

    .modal-content {
      background-color: var(--bg);
      padding: 30px;
      border-radius: var(--radius);
      box-shadow: var(--shadow-xl);
      text-align: center;
      max-width: 400px;
      width: 90%;
      position: relative;
      animation: slideUp 0.3s ease-out;
    }

    .modal-content input {
      width: calc(100% - 20px);
      padding: 10px;
      margin-bottom: 15px;
      border: 1px solid #ccc;
      border-radius: var(--radius-sm);
      font-size: 1rem;
    }

    .modal-close {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 24px;
      font-weight: bold;
      color: var(--text-light);
      cursor: pointer;
      background: none;
      border: none;
    }

    .modal-close:hover {
      color: var(--accent);
    }

    /* Global Popup Notification */
    .global-popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.4);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      animation: fadeIn 0.3s ease-out;
      pointer-events: auto;
    }

    .global-popup-box {
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      padding: 2rem;
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-xl);
      text-align: center;
      max-width: min(500px, 90vw);
      width: 100%;
      border: 1px solid rgba(255,255,255,0.2);
      animation: slideUp 0.3s ease-out;
      color: var(--primary);
    }

    .notif-message {
      font-family: 'Poppins', sans-serif;
      font-size: clamp(1.2rem, 3vw, 1.5rem);
      margin-bottom: 1rem;
      color: var(--text);
    }

    .notif-cards {
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .notif-cards .card {
      width: 80px;
      height: 120px;
      font-size: 0.8rem;
    }

    .notif-cards .card .suit.main {
      font-size: 2.5rem;
    }

    /* Chat Styling */
    #chat-container {
      position: fixed;
      bottom: 0;
      right: 20px;
      width: var(--chat-width);
      height: var(--chat-height);
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(10px);
      border-top-left-radius: var(--radius);
      border-top-right-radius: var(--radius);
      box-shadow: var(--shadow-lg);
      display: flex;
      flex-direction: column;
      z-index: 100;
      overflow: hidden;
    }

    .chat-header {
      background: var(--gradient-primary);
      padding: 0.75rem 1rem;
      color: var(--text-white);
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
      font-size: 1.1rem;
      font-weight: 500;
    }

    .chat-header span {
      transition: transform 0.3s ease;
    }
    
    #chat-container.collapsed {
      height: 40px;
    }

    #chat-container.collapsed .chat-content {
      display: none;
    }

    #chat-container.collapsed .chat-header span {
      transform: rotate(180deg);
    }

    .chat-content {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      padding: 0.75rem;
      overflow-y: auto;
      background: rgba(255,255,255,0.1);
    }

    #chat-messages {
      flex-grow: 1;
      overflow-y: auto;
      margin-bottom: 0.75rem;
      color: var(--text-white);
      font-size: 0.9rem;
      line-height: 1.4;
      word-wrap: break-word;
    }

    .message.me {
      text-align: right;
      color: var(--accent);
    }

    .message.other {
      text-align: left;
      color: var(--secondary);
    }

    .chat-form {
      display: flex;
      gap: 0.5rem;
    }

    #chat-input {
      flex-grow: 1;
      padding: 0.5rem;
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: var(--radius-sm);
      background: rgba(255,255,255,0.1);
      color: var(--text-white);
      font-size: 0.9rem;
    }

    #chat-input::placeholder {
      color: rgba(255,255,255,0.7);
    }

    #chat-input:focus {
      outline: none;
      border-color: var(--secondary);
    }

    .chat-form button {
      padding: 0.5rem 1rem;
      background: var(--gradient-success);
      color: var(--text-white);
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: var(--transition);
    }

    .chat-form button:hover {
      filter: brightness(1.1);
    }

    /* Hand Display Options */
    .hand-display-options {
      position: absolute;
      top: -50px;
      right: 20px;
      display: flex;
      gap: 0.5rem;
      z-index: 70;
    }

    .hand-display-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: var(--transition);
    }

    .hand-display-btn:hover {
      background: var(--gradient-primary);
      color: white;
    }

    .hand-display-btn.active {
      background: var(--gradient-success);
      color: white;
    }
    
    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from { transform: translateY(50px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      :root {
        --card-width: 100px;
        --card-height: 150px;
        --chat-width: 100%;
        --chat-height: 250px;
      }

      .menu-content {
        padding: 1.5rem;
      }

      .btn {
        font-size: 0.9rem;
        padding: 0.6rem 1rem;
      }

      .game-header {
        flex-direction: column;
        gap: 0.5rem;
      }

      .header-left,
      .header-right {
        width: 100%;
        justify-content: center;
      }

      .header-center {
        order: unset;
      }

      .game-controls {
        position: fixed;
        top: 80px;
        right: 20px;
        z-index: 150;
      }

      #hand .card {
        margin-right: -50px;
      }

      .hand-display-options {
        top: -40px;
        right: 10px;
      }

      #chat-container {
        right: 0;
        border-radius: 0;
      }
      
      #joker {
        top: 60px;
        left: 10px;
      }
    }
  </style>
</head>
<body>
  <!-- Menu de connexion/cr√©ation -->
  <div id="menu" class="menu-overlay">
    <div class="menu-content">
      <h1>Bienvenue au Rami !</h1>
      <!-- Cr√©ation de partie -->
      <div class="menu-section">
        <button id="createRoom" class="btn btn-primary">
          Cr√©er une nouvelle partie
        </button>
      </div>
      <div class="separator">OU</div>
      <!-- Rejoindre une partie -->
      <div class="menu-section">
        <h2>Rejoindre une partie</h2>
        <div class="join-form">
          <input
            id="roomCodeInput"
            class="room-input"
            type="text"
            maxlength="7"
            placeholder="Code de partie (RAMI123)"
            pattern="RAMI\\d{3}"
          />
          <button id="joinRoom" class="btn btn-secondary">
            Rejoindre
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Plateau de jeu -->
  <div id="game" style="display: none;">
    <header class="game-header">
      <div class="header-left">
        <span id="status" class="game-status">
          Pr√©paration de la partie...
        </span>
        <span id="roomCodeDisplay"></span>
      </div>
      <div class="header-right">
        <!-- Contr√¥les d'affichage de la main -->
        <div class="hand-display-options">
          <button class="hand-display-btn" data-display="horizontal">‚Üî</button>
          <button class="hand-display-btn" data-display="vertical">‚Üï</button>
        </div>
      </div>
    </header>

    <div class="game-play-area">
      <!-- Contr√¥les -->
      <aside class="game-controls">
        <button id="startGameBtn" class="btn-action" style="display: none;">
          D√©marrer la partie
        </button>
        <button id="sortHandBtn" class="btn-special">
          Ranger les cartes
        </button>
        <button id="endTurnBtn" class="btn-action" disabled>
          Terminer le tour
        </button>
        <button id="declare7N" class="btn-special" disabled>
          D√©clarer 7 Naturel
        </button>
        <button id="declareWin" class="btn-special" disabled>
          D√©clarer Victoire
        </button>
      </aside>

      <!-- Joker en haut √† gauche -->
      <div id="joker">
        <div class="joker-label">Joker</div>
        <div class="card back"></div>
      </div>

      <!-- Liste des joueurs avec d√©fausse -->
      <div id="players-container">
        <!-- Les emplacements des joueurs seront ajout√©s dynamiquement -->
      </div>

      <!-- Plateau central - Pioche seule -->
      <div class="game-table-container">
        <div class="table-center">
          <!-- Pioche -->
          <div class="deck-area">
            <div id="deck" class="deck-pile clickable">
              <div class="card back"></div>
            </div>
            <div class="deck-label">Pioche</div>
          </div>
        </div>
      </div>

      <!-- Main du joueur -->
      <div id="hand-container">
        <div id="hand" class="player-hand horizontal"></div>
      </div>

      <!-- Chat -->
      <div id="chat-container">
        <div class="chat-header">
          <h3>Chat</h3><span>‚ñº</span>
        </div>
        <div class="chat-content">
          <div id="chat-messages"></div>
          <form id="chat-form">
            <input
              id="chat-input"
              type="text"
              placeholder="Message‚Ä¶"
              autocomplete="off"
            />
            <button type="submit">Envoyer</button>
          </form>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // Votre code JavaScript complet va ici
    import { db, ref, push, onChildAdded, set, update, get, onValue } from './firebase.js';
    import Sortable from 'https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/modular/sortable.esm.js';

    let myPseudo = '';
    const playerId = 'player_' + Math.floor(Math.random() * 10000);
    const playersMap = {};
    let currentRoom = '';
    let isDrawing = false;
    let hasDrawnOrPicked = false;
    let hasDiscardedThisTurn = false;
    let handDisplayType = 'horizontal';
    let currentHand = [];
    let gameRounds = 0;
    let jokerSet = [];

    // NOUVELLE LOGIQUE DE R√àGLES
    const Rules = {
      // Validation principale de victoire
      validateWinHand(hand, jokerCards, has7Naturel) {
        const naturalCards = hand.filter(c => !jokerCards.includes(c.id));
        const jokers = hand.filter(c => jokerCards.includes(c.id));
        
        // Extraire toutes les formations possibles
        const formations = this.extractAllFormations(naturalCards, jokers);
        
        // Si 7N, les 2 formations de 3 peuvent √™tre tri avec 1 joker max
        if (has7Naturel) {
          return this.validateWith7N(formations, naturalCards, jokers);
        }
        
        // Sinon, besoin d'au moins 1 escalier et 1 tri, jokers autoris√©s
        return this.validateWithout7N(formations, naturalCards, jokers);
      },
      
      extractAllFormations(naturalCards, jokers) {
        const formations = {
          quadri: [],
          escalier4: [],
          escalier3: [],
          tri: []
        };
        
        // Formations naturelles
        this.extractNaturalFormations(formations, naturalCards);
        
        // Formations avec jokers (1 max par formation)
        this.extractJokerFormations(formations, naturalCards, jokers);
        
        return formations;
      },
      
      extractNaturalFormations(formations, cards) {
        // Par valeur pour quadri et tri
        const byValue = cards.reduce((acc, c) => {
          acc[c.value] = acc[c.value] || [];
          acc[c.value].push(c);
          return acc;
        }, {});
        
        Object.entries(byValue).forEach(([value, cards]) => {
          if (cards.length >= 4) {
            formations.quadri.push({cards: cards.slice(0, 4), type: 'natural'});
          }
          if (cards.length === 3) {
            formations.tri.push({cards, type: 'natural'});
          }
        });
        
        // Par couleur pour escaliers
        const bySuit = cards.reduce((acc, c) => {
          acc[c.suit] = acc[c.suit] || [];
          acc[c.suit].push(c);
          return acc;
        }, {});
        
        Object.entries(bySuit).forEach(([suit, cards]) => {
          const sorted = cards.sort((a, b) => a.value - b.value);
          
          // Escalier de 4
          for (let i = 0; i <= sorted.length - 4; i++) {
            if (sorted[i+3].value === sorted[i].value + 3) {
              formations.escalier4.push({cards: sorted.slice(i, i+4), type: 'natural'});
            }
          }
          
          // Escalier de 3
          for (let i = 0; i <= sorted.length - 3; i++) {
            if (sorted[i+2].value === sorted[i].value + 2) {
              formations.escalier3.push({cards: sorted.slice(i, i+3), type: 'natural'});
            }
          }
        });
      },
      
      extractJokerFormations(formations, naturalCards, jokers) {
        jokers.forEach(joker => {
          // Escalier de 3 avec 1 joker
          const bySuit = naturalCards.reduce((acc, c) => {
            acc[c.suit] = acc[c.suit] || [];
            acc[c.suit].push(c);
            return acc;
          }, {});
          
          Object.entries(bySuit).forEach(([suit, cards]) => {
            const sorted = cards.sort((a, b) => a.value - b.value);
            
            // Trouver les s√©quences manquantes
            for (let i = 0; i < sorted.length - 1; i++) {
              const gap = sorted[i+1].value - sorted[i].value;
              if (gap === 2) {
                const neededValue = sorted[i].value + 1;
                formations.escalier3.push({
                  cards: [sorted[i], {...joker, value: neededValue, suit}, sorted[i+1]],
                  type: 'joker',
                  jokerUsed: 1
                });
              }
            }
          });
          
          // Tri avec 1 joker
          Object.entries(naturalCards.reduce((acc, c) => {
            acc[c.value] = acc[c.value] || [];
            acc[c.value].push(c);
            return acc;
          }, {})).forEach(([value, cards]) => {
            if (cards.length === 2) {
              formations.tri.push({
                cards: [...cards, {...joker, value}],
                type: 'joker',
                jokerUsed: 1
              });
            }
          });
        });
      },
      
      validateWithout7N(formations, naturalCards, jokers) {
        // Besoin d'au moins 1 escalier et 1 tri
        const escaliers = [...formations.escalier4, ...formations.escalier3];
        const tris = formations.tri;
        
        if (escaliers.length === 0 || tris.length === 0) return false;
        
        // Chercher 4 formations disjointes totalisant 13 cartes
        return this.findDisjointFormations([...escaliers, ...formations.quadri, ...tris]);
      },
      
      validateWith7N(formations, naturalCards, jokers) {
        // Le 7N compte pour 2 formations (4+3 cartes)
        // Il reste 2 formations de 3 cartes chacune, avec 1 joker max par formation
        const remainingCards = this.getRemainingCards(naturalCards, jokers, formations);
        return this.canFormTwoTriWithJokers(remainingCards);
      },
      
      findDisjointFormations(allFormations) {
        // Logique de recherche de 4 formations disjointes
        // Impl√©mentation simplifi√©e pour l'instant
        let totalCards = 0;
        const usedCards = new Set();
        
        allFormations.forEach(formation => {
          formation.cards.forEach(card => {
            if (!usedCards.has(card.id)) {
              usedCards.add(card.id);
              totalCards++;
            }
          });
        });
        
        return totalCards >= 13;
      },
      
      // V√©rifie le 7 naturel (sans joker)
      has7Naturel(hand, jokerCards) {
        const naturalCards = hand.filter(c => !jokerCards.includes(c.id));
        
        // Quadri + escalier3
        const quadri = this.findNaturalQuadri(naturalCards);
        const escalier3 = this.findNaturalEscalier3(naturalCards);
        
        if (quadri && escalier3) {
          const cards = [...quadri, ...escalier3];
          if (cards.length === 7) return true;
        }
        
        // Escalier4 + tri
        const escalier4 = this.findNaturalEscalier4(naturalCards);
        const tri = this.findNaturalTri(naturalCards);
        
        if (escalier4 && tri) {
          const cards = [...escalier4, ...tri];
          if (cards.length === 7) return true;
        }
        
        return false;
      },
      
      findNaturalQuadri(cards) {
        const byValue = cards.reduce((acc, c) => {
          acc[c.value] = acc[c.value] || [];
          acc[c.value].push(c);
          return acc;
        }, {});
        
        const quadri = Object.values(byValue).find(vals => vals.length >= 4);
        return quadri ? quadri.slice(0, 4) : null;
      },
      
      findNaturalEscalier3(cards) {
        const bySuit = cards.reduce((acc, c) => {
          acc[c.suit] = acc[c.suit] || [];
          acc[c.suit].push(c);
          return acc;
        }, {});
        
        for (const suitCards of Object.values(bySuit)) {
          const sorted = suitCards.sort((a, b) => a.value - b.value);
          for (let i = 0; i <= sorted.length - 3; i++) {
            if (sorted[i+2].value === sorted[i].value + 2) {
              return sorted.slice(i, i+3);
            }
          }
        }
        return null;
      },
      
      findNaturalEscalier4(cards) {
        const bySuit = cards.reduce((acc, c) => {
          acc[c.suit] = acc[c.suit] || [];
          acc[c.suit].push(c);
          return acc;
        }, {});
        
        for (const suitCards of Object.values(bySuit)) {
          const sorted = suitCards.sort((a, b) => a.value - b.value);
          for (let i = 0; i <= sorted.length - 4; i++) {
            if (sorted[i+3].value === sorted[i].value + 3) {
              return sorted.slice(i, i+4);
            }
          }
        }
        return null;
      },
      
      findNaturalTri(cards) {
        const byValue = cards.reduce((acc, c) => {
          acc[c.value] = acc[c.value] || [];
          acc[c.value].push(c);
          return acc;
        }, {});
        
        const tri = Object.values(byValue).find(vals => vals.length === 3);
        return tri || null;
      }
    };

    // FONCTIONS UTILITAIRES
    function getCardValue(rank) {
      switch (rank) {
        case 'A': return 1;
        case 'J': return 11;
        case 'Q': return 12;
        case 'K': return 13;
        default: return parseInt(rank, 10);
      }
    }

    function createDeck() {
      const suits = [
        { suit: 'Coeurs', symbol: '‚ô•', color: 'red' },
        { suit: 'Carreaux', symbol: '‚ô¶', color: 'red' },
        { suit: 'Tr√®fles', symbol: '‚ô£', color: 'black' },
        { suit: 'Piques', symbol: '‚ô†', color: 'black' }
      ];
      const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
      let deck = [];

      for (let d = 0; d < 2; d++) {
        suits.forEach(suitObj => {
          ranks.forEach(rank => {
            const value = getCardValue(rank);
            deck.push({
              suit: suitObj.suit,
              symbol: suitObj.symbol,
              color: suitObj.color,
              rank,
              value,
              id: `${rank}${suitObj.symbol}${d}`
            });
          });
        });
      }
      return deck;
    }

    function shuffle(array) {
      let currentIndex = array.length, randomIndex;
      while (currentIndex !== 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
      }
      return array;
    }

    async function dealCards(roomId, playerIds) {
      let deck = shuffle(createDeck());
      const hands = {};
      playerIds.forEach(pid => {
        hands[pid] = deck.splice(0, 13);
      });
      const revealedJokerCard = deck.shift();
      
      // D√©terminer les jokers (m√™me valeur, couleur oppos√©e)
      jokerSet = deck
        .filter(c => c.value === revealedJokerCard.value && c.color !== revealedJokerCard.color)
        .map(c => c.id);

      await Promise.all([
        set(ref(db, `rooms/${roomId}/deck`), deck),
        set(ref(db, `rooms/${roomId}/jokerCard`), revealedJokerCard),
        set(ref(db, `rooms/${roomId}/jokerSet`), jokerSet),
        set(ref(db, `rooms/${roomId}/hands`), hands),
        set(ref(db, `rooms/${roomId}/discard`), {}),
        set(ref(db, `rooms/${roomId}/scores`), {}),
        set(ref(db, `rooms/${roomId}/state`), {
          started: false,
          drawCount: 0,
          lastDiscarder: null,
          hasDrawnOrPicked: false,
          hasDiscardedThisTurn: false,
          sevenDeclared: false,
          winDeclared: false,
          roundOver: false,
          lastDiscardPlayer: null,
          lastDiscardCard: null,
          gameRound: gameRounds
        }),
        set(ref(db, `rooms/${roomId}/chat`), {})
      ]);
    }

    // INITIALISATION DES BOUTONS
    const btnCreate = document.getElementById('createRoom');
    const btnJoin   = document.getElementById('joinRoom');
    if (btnCreate) btnCreate.addEventListener('click', createRoom);
    if (btnJoin)   btnJoin.addEventListener('click', joinRoom);

    // FONCTIONS PRINCIPALES
    function askPseudo() {
      return new Promise(resolve => {
        showPopup(`
          <h3>Entrez votre pseudo</h3>
          <input id="pseudoInput" type="text" placeholder="Votre pseudo" maxlength="15" style="width: 100%; padding: 0.5rem; margin: 1rem 0;" />
          <button id="pseudoSubmit" class="btn btn-primary">Valider</button>
        `);
        document.getElementById('pseudoSubmit').addEventListener('click', () => {
          const val = document.getElementById('pseudoInput').value.trim();
          myPseudo = val || 'Joueur';
          document.querySelector('.modal')?.remove();
          resolve();
        });
      });
    }

    async function createRoom() {
      await askPseudo();

      const roomCode = 'RAMI' + Math.floor(100 + Math.random() * 900);
      currentRoom = roomCode;
      gameRounds = 0;

      // üîß Affichage du code de la partie
      showPopup(`
        <h3>üéâ Salle cr√©√©e</h3>
        <p>Partage ce code :</p>
        <b style="font-size: 1.5rem; color: #e74c3c;">${roomCode}</b>
        <br><br>
        <button onclick="navigator.clipboard.writeText('${roomCode}')" class="btn btn-secondary">üìã Copier</button>
        <br><br>
        <button class="btn btn-primary modal-close">Continuer</button>
      `);

      await set(ref(db, `rooms/${roomCode}/players/${playerId}`), {
        pseudo: myPseudo,
        hasDeclared7N: false,
        score: 0,
        isSpectator: false,
        sevenNPoints: 0,
        totalScore: 0
      });
      await set(ref(db, `rooms/${roomCode}/creator`), playerId);

      setupListeners(roomCode);
      document.getElementById('menu').style.display = 'none';
      document.getElementById('game').style.display = 'flex';
    }

    async function joinRoom() {
      const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
      if (!/^RAMI\d{3}$/.test(roomCode)) return showPopup("Code invalide (format: RAMI123)", true);

      const roomRef = ref(db, `rooms/${roomCode}`);
      const snapshot = await get(roomRef);
      if (!snapshot.exists()) return showPopup("Salle introuvable", true);

      await askPseudo();
      await set(ref(db, `rooms/${roomCode}/players/${playerId}`), {
        pseudo: myPseudo,
        hasDeclared7N: false,
        score: 0,
        isSpectator: false,
        sevenNPoints: 0,
        totalScore: 0
      });

      currentRoom = roomCode;
      setupListeners(roomCode);
      document.getElementById('menu').style.display = 'none';
      document.getElementById('game').style.display = 'flex';
    }

    function setupListeners(roomCode) {
      listenPlayers(roomCode);
      listenHand(roomCode);
      listenTurn(roomCode);
      listenJokerCard(roomCode);
      listenDiscard(roomCode);
      listenChat(roomCode);

      // üîß √âcouteurs
      document.getElementById('startGameBtn')?.addEventListener('click', startGame);
      document.getElementById('deck')?.addEventListener('click', drawCard);
      setupHandDisplayOptions();
      enableChat();
      enableDragDrop();
      
      // Nouvel √©couteur pour la d√©fausse centrale
      document.getElementById('discard')?.addEventListener('click', () => {
        if (!currentRoom) return;
        pickFromDiscard();
      });

      // ‚úÖ √âcouteur pour le bouton "Ranger les cartes"
      document.getElementById('sortHandBtn')?.addEventListener('click', sortHandByFormation);
    }
      // ‚úÖ NOUVEAU : √âcouteur global pour les clics sur les d√©fausses des autres joueurs
  document.addEventListener('click', (e) => {
    const discardSlot = e.target.closest('.player-discard');
    if (!discardSlot) return;

    const ownerId = discardSlot.dataset.owner;
    if (!ownerId || ownerId === playerId) return;

    handlePickFromPreviousDiscard(ownerId);
  });
}
    async function startGame() {
      const playersSnap = await get(ref(db, `rooms/${currentRoom}/players`));
      const players = playersSnap.val() || {};
      const playerIds = Object.keys(players);

      await dealCards(currentRoom, playerIds);
      await set(ref(db, `rooms/${currentRoom}/turn`), playerIds[0]);
      
      // ‚úÖ Toutes les valeurs d√©finies
      await update(ref(db, `rooms/${currentRoom}/state`), { 
        started: true,
        sevenDeclared: false,
        winDeclared: false,
        roundOver: false,
        gameRound: 0,
        drawCount: 0,
        hasDrawnOrPicked: false,
        hasDiscardedThisTurn: false
      });
      
      // ‚úÖ Mise √† jour s√©curis√©e de tous les joueurs
      const updates = {};
      playerIds.forEach(id => {
        updates[`${id}/isSpectator`] = false;
        updates[`${id}/hasDeclared7N`] = false;
        updates[`${id}/score`] = 0;
        updates[`${id}/sevenNPoints`] = 0;
        updates[`${id}/totalScore`] = 0;
      });
      
      await update(ref(db, `rooms/${currentRoom}/players`), updates);
      
      document.getElementById('startGameBtn').style.display = 'none';
    }

    // GESTION DES D√âCLARATIONS
    async function declare7Naturel() {
      const state = (await get(ref(db, `rooms/${currentRoom}/state`))).val() || {};
      if (state.sevenDeclared) {
        showPopup("Un 7N a d√©j√† √©t√© d√©clar√©.");
        return;
      }

      const hand = (await get(ref(db, `rooms/${currentRoom}/hands/${playerId}`))).val() || [];
      const jokerCards = (await get(ref(db, `rooms/${currentRoom}/jokerSet`))).val() || [];
      
      if (!Rules.has7Naturel(hand, jokerCards)) {
        showPopup("Pas de 7 Naturel valide.");
        return;
      }

      const points = gameRounds === 0 ? 0.5 : 1.0;
      await Promise.all([
        update(ref(db, `rooms/${currentRoom}/players/${playerId}`), {
          hasDeclared7N: true,
          sevenNPoints: points
        }),
        update(ref(db, `rooms/${currentRoom}/state`), {
          sevenDeclared: true,
          sevenDeclarant: playerId
        })
      ]);

      showGlobalPopup(`üéâ ${myPseudo} d√©clare 7N (+${points} pts)`, []);
    }

    async function declareWin() {
      const hand = (await get(ref(db, `rooms/${currentRoom}/hands/${playerId}`))).val() || [];
      const jokerCards = (await get(ref(db, `rooms/${currentRoom}/jokerSet`))).val() || [];
      
      if (!Rules.validateWinHand(hand, jokerCards, false)) {
        showPopup("Main non valide pour la victoire.", true);
        return;
      }

      const winBonus = gameRounds + 1;
      const sevenNPoints = (await get(ref(db, `rooms/${currentRoom}/players/${playerId}/sevenNPoints`))).val() || 0;
      const totalScore = sevenNPoints + winBonus;

      await update(ref(db, `rooms/${currentRoom}/players/${playerId}`), {
        totalScore,
        winBonus
      });

      await update(ref(db, `rooms/${currentRoom}/state`), {
        winDeclared: true,
        winner: playerId,
        winnerName: myPseudo
      });

      showGlobalPopup(`üèÜ ${myPseudo} gagne ! (+${winBonus} pts)`, []);
    }

    // AFFICHAGE DES CARTES
    function renderHand(hand) {
      const handDiv = document.getElementById('hand');
      if (!handDiv) return; // S√©curit√© si l'√©l√©ment n'existe pas

      handDiv.innerHTML = '';

      hand.forEach(card => {
        const div = document.createElement('div');
        div.className = `card ${card.color}`;
        div.dataset.cardId = card.id;
        div.dataset.rank = card.rank;
        div.dataset.symbol = card.symbol;
        div.dataset.color = card.color;
        div.dataset.suit = card.suit;
        div.dataset.value = card.value;

        div.innerHTML = `
          <div class="corner top">${card.rank}${card.symbol}</div>
          <div class="suit main">${card.symbol}</div>
        `;

        div.addEventListener('dblclick', () => discardCard(card.id));

        handDiv.appendChild(div);
      });
    }
    function getPreviousPlayerId(currentPlayerId, allPlayers) {
      const index = allPlayers.indexOf(currentPlayerId);
      const prevIndex = (index - 1 + allPlayers.length) % allPlayers.length;
      return allPlayers[prevIndex];
    }

    // Fonction pour cr√©er l'√©l√©ment d'une carte
    function createCardElement(card) {
      const div = document.createElement('div');
      div.className = `card ${card.color}`;
      div.dataset.cardId = card.id;
      div.dataset.rank = card.rank;
      div.dataset.symbol = card.symbol;
      div.dataset.color = card.color;
      div.dataset.suit = card.suit;
      div.dataset.value = card.value;

      div.innerHTML = `
        <div class="corner top">${card.rank}${card.symbol}</div>
        <div class="suit main">${card.symbol}</div>
      `;
      return div;
    }

async function renderDiscardPiles(discards) {
  const [turnSnap, playersSnap] = await Promise.all([
    get(ref(db, `rooms/${currentRoom}/turn`)),
    get(ref(db, `rooms/${currentRoom}/players`))
  ]);
  const turn = turnSnap.val();
  const players = Object.keys(playersSnap.val() || {});

  document.querySelectorAll('.player-discard').forEach(slot => {
    const ownerId = slot.dataset.owner;
    const pile = discards[ownerId] || [];
    slot.innerHTML = '';

    if (pile.length) {
      const lastCard = pile[pile.length - 1];
      const cardDiv = createCardElement(lastCard);

      const nextOfOwner = players[(players.indexOf(ownerId) + 1) % players.length];
      if (turn === playerId && playerId === nextOfOwner) {
        cardDiv.classList.add('clickable');
      }

      slot.appendChild(cardDiv);
    } else {
      slot.innerHTML = '<div class="no-card">Pas de carte</div>';
    }
  });
}

    function listenDiscard(room) {
      onValue(ref(db, `rooms/${room}/discard`), async snap => {
        const discards = snap.val() || {};
        renderDiscardPiles(discards); // on appelle seulement renderDiscardPiles
      });
    }

    async function pickFromPreviousDiscard(cardId, prevPlayerId) {
      if (isDrawing) return;
      isDrawing = true;
      const prevSlot = document.querySelector(`.player-discard[data-owner="${prevPlayerId}"]`);
      prevSlot?.classList.add('no-click');

      try {
        const turn = (await get(ref(db, `rooms/${currentRoom}/turn`))).val();
        if (turn !== playerId) {
          showPopup("Ce n'est pas votre tour.", true);
          return;
        }

        const state = (await get(ref(db, `rooms/${currentRoom}/state`))).val() || {};
        if (state.hasDrawnOrPicked) {
          showPopup("Vous avez d√©j√† pioch√©.", true);
          return;
        }

        // V√©rifier que le joueur est bien le suivant de prevPlayerId
        const players = Object.keys((await get(ref(db, `rooms/${currentRoom}/players`))).val() || {});
        const nextOfPrev = players[(players.indexOf(prevPlayerId) + 1) % players.length];
        if (playerId !== nextOfPrev) {
          showPopup("Vous ne pouvez pas piocher dans cette d√©fausse.", true);
          return;
        }

        const discards = (await get(ref(db, `rooms/${currentRoom}/discard`))).val() || {};
        const pile = discards[prevPlayerId] || [];
        if (!pile.length) {
          showPopup("Rien √† piocher ici.", true);
          return;
        }

        const card = pile[pile.length - 1];
        const newPile = pile.slice(0, -1);
        const hand = (await get(ref(db, `rooms/${currentRoom}/hands/${playerId}`))).val() || [];

        await Promise.all([
          set(ref(db, `rooms/${currentRoom}/discard/${prevPlayerId}`), newPile),
          set(ref(db, `rooms/${currentRoom}/hands/${playerId}`), [...hand, card]),
          update(ref(db, `rooms/${currentRoom}/state`), { hasDrawnOrPicked: true })
        ]);

      } catch (err) {
        console.error(err);
      } finally {
        isDrawing = false;
        prevSlot?.classList.remove('no-click');
      }
    }
    
    async function sortHandByFormation() {
      const hand = (await get(ref(db, `rooms/${currentRoom}/hands/${playerId}`))).val() || [];
      const jokerCards = (await get(ref(db, `rooms/${currentRoom}/jokerSet`))).val() || [];

      // Trie par valeur, puis par couleur
      const sorted = [...hand].sort((a, b) => {
        if (a.value !== b.value) return a.value - b.value;
        const suitOrder = ['‚ô†', '‚ô£', '‚ô¶', '‚ô•'];
        return suitOrder.indexOf(a.symbol) - suitOrder.indexOf(b.symbol);
      });

      await set(ref(db, `rooms/${currentRoom}/hands/${playerId}`), sorted);
    }
    // LISTENERS
    function listenPlayers(room) {
      onValue(ref(db, `rooms/${room}/players`), async snap => {
        const players = Object.entries(snap.val() || {}).map(([id, o]) => {
          playersMap[id] = { pseudo: o.pseudo, totalScore: o.totalScore || 0 };
          return { id, pseudo: o.pseudo, score: o.totalScore || 0 };
        });
        renderPlayers(players);

        const creator = (await get(ref(db, `rooms/${room}/creator`))).val();
        const state = (await get(ref(db, `rooms/${room}/state`))).val() || {};
        const btn = document.getElementById('startGameBtn');
        btn.style.display = (creator === playerId && !state.started) ? 'block' : 'none';
      });
    }

    function renderPlayers(players) {
      const container = document.getElementById('players-container');
      container.innerHTML = '';

      players.forEach((currentPlayer, index) => {
        const prevIndex = (index - 1 + players.length) % players.length;
        const prevPlayer = players[prevIndex];

        const playerDiv = document.createElement('div');
        playerDiv.className = 'player-slot';
        playerDiv.dataset.playerId = currentPlayer.id; // stocke l'id du joueur actuel

        playerDiv.innerHTML = `
          <div class="player-info ${currentPlayer.id === playerId ? 'active' : ''}">
            <div class="player-name">${currentPlayer.pseudo}</div>
            <div class="player-hand-count">${currentPlayer.score} pts</div>
          </div>
          <div class="player-discard" data-owner="${prevPlayer.id}">
            <!-- La d√©fausse du joueur pr√©c√©dent sera inject√©e ici -->
          </div>
        `;
        container.appendChild(playerDiv);
      });
    }

    function listenHand(room) {
      onValue(ref(db, `rooms/${room}/hands/${playerId}`), snap => {
        const hand = snap.val() || [];
        renderHand(hand);
      });
    }

    function listenTurn(room) {
      onValue(ref(db, `rooms/${room}/turn`), snap => {
        const turn = snap.val();
        const myTurn = turn === playerId;
        hasDrawnOrPicked = false;
        hasDiscardedThisTurn = false;

        document.getElementById('status').textContent = myTurn ? "Votre tour" : "En attente...";
        document.getElementById('endTurnBtn').disabled = !myTurn;
      });
    }

    function listenJokerCard(room) {
      onValue(ref(db, `rooms/${room}/jokerCard`), snap => {
        const card = snap.val();
        const jokerDiv = document.getElementById('joker');
        if (!jokerDiv) return; // S√©curit√© si l'√©l√©ment n'existe pas
        
        if (card) {
          jokerDiv.innerHTML = `
            <div class="card ${card.color}">
              <div class="corner top">${card.rank}${card.symbol}</div>
              <div class="suit main">${card.symbol}</div>
            </div>
          `;
        } else {
          jokerDiv.innerHTML = '';
        }
      });
    }

    // GESTION DES D√âFAUSSES
    async function renderPreviousDiscard(discards) {
      const playersSnap = await get(ref(db, `rooms/${currentRoom}/players`));
      const players = Object.keys(playersSnap.val() || {});
      const currentIndex = players.indexOf(playerId);
      const prevPlayerId = players[(currentIndex - 1 + players.length) % players.length];

      const pile = discards[prevPlayerId] || [];
      const lastCard = pile[pile.length - 1];

      const container = document.querySelector(`.player-discard[data-owner="${prevPlayerId}"]`);
      if (!container) return;

      container.innerHTML = '';

      if (lastCard) {
        const name = playersMap[prevPlayerId]?.pseudo || prevPlayerId;

        const cardDiv = document.createElement('div');
        cardDiv.className = `card ${lastCard.color}`;
        cardDiv.dataset.cardId = lastCard.id;
        cardDiv.innerHTML = `
          <div class="corner top">${lastCard.rank}${lastCard.symbol}</div>
          <div class="suit main">${lastCard.symbol}</div>
        `;

        const turn = (await get(ref(db, `rooms/${currentRoom}/turn`))).val();
        const nextOfPrev = players[(players.indexOf(prevPlayerId) + 1) % players.length];

        if (turn === playerId && playerId === nextOfPrev) {
          cardDiv.classList.add('clickable');
          cardDiv.addEventListener('click', () => pickFromPreviousDiscard(lastCard.id, prevPlayerId));
        }

        container.appendChild(cardDiv);
      } else {
        container.innerHTML = '<div class="no-card">Pas de carte</div>';
      }
    }

    // ACTIONS DU JEU
    async function drawCard() {
      if (isDrawing) return;
      isDrawing = true;
      const deckEl = document.getElementById('deck');
      deckEl.classList.add('no-click');
      try {
        const turn = (await get(ref(db, `rooms/${currentRoom}/turn`))).val();
        if (turn !== playerId) throw "Ce n'est pas votre tour.";

        const state = (await get(ref(db, `rooms/${currentRoom}/state`))).val() || {};
        if (state.hasDrawnOrPicked) throw "Vous avez d√©j√† pioch√©.";

        const [deckSnap, handSnap] = await Promise.all([
          get(ref(db, `rooms/${currentRoom}/deck`)),
          get(ref(db, `rooms/${currentRoom}/hands/${playerId}`))
        ]);
        const deckCards = deckSnap.val() || [];
        if (!deckCards.length) throw "Deck vide.";

        const card = deckCards.shift();
        const newHand = [...(handSnap.val() || []), card];

        await Promise.all([
          set(ref(db, `rooms/${currentRoom}/deck`), deckCards),
          set(ref(db, `rooms/${currentRoom}/hands/${playerId}`), newHand),
          update(ref(db, `rooms/${currentRoom}/state`), { hasDrawnOrPicked: true })
        ]);
      } catch (err) {
        if (typeof err === "string") showPopup(err, true);
        else console.error(err);
      } finally {
        isDrawing = false;
        deckEl.classList.remove('no-click');
      }
    }
async function handlePickFromPreviousDiscard(ownerId) {
  if (isDrawing) return;
  isDrawing = true;

  try {
    const turn = (await get(ref(db, `rooms/${currentRoom}/turn`))).val();
    if (turn !== playerId) {
      showPopup("Ce n'est pas votre tour.", true);
      return;
    }

    const state = (await get(ref(db, `rooms/${currentRoom}/state`))).val() || {};
    if (state.hasDrawnOrPicked) {
      showPopup("Vous avez d√©j√† pioch√©.", true);
      return;
    }

    const players = Object.keys((await get(ref(db, `rooms/${currentRoom}/players`))).val() || {});
    const nextOfOwner = players[(players.indexOf(ownerId) + 1) % players.length];

    if (playerId !== nextOfOwner) {
      showPopup("Vous ne pouvez pas piocher dans cette d√©fausse.", true);
      return;
    }

    const discards = (await get(ref(db, `rooms/${currentRoom}/discard`))).val() || {};
    const pile = discards[ownerId] || [];
    if (!pile.length) {
      showPopup("Rien √† piocher ici.", true);
      return;
    }

    const card = pile[pile.length - 1];
    const newPile = pile.slice(0, -1);
    const hand = (await get(ref(db, `rooms/${currentRoom}/hands/${playerId}`))).val() || [];

    await Promise.all([
      set(ref(db, `rooms/${currentRoom}/discard/${ownerId}`), newPile),
      set(ref(db, `rooms/${currentRoom}/hands/${playerId}`), [...hand, card]),
      update(ref(db, `rooms/${currentRoom}/state`), { hasDrawnOrPicked: true })
    ]);

  } catch (err) {
    console.error("Erreur lors de la prise depuis la d√©fausse :", err);
  } finally {
    isDrawing = false;
  }
}

    async function discardCard(cardId) {
      const turn = (await get(ref(db, `rooms/${currentRoom}/turn`))).val();
      if (turn !== playerId) return showPopup("Ce n'est pas votre tour.");

      const state = (await get(ref(db, `rooms/${currentRoom}/state`))).val() || {};
      if (!state.hasDrawnOrPicked) {
        showPopup("Piochez d'abord.");
        return;
      }
      if (state.hasDiscardedThisTurn) {
        showPopup("Vous avez d√©j√† d√©fauss√©.");
        return;
      }

      const hand = (await get(ref(db, `rooms/${currentRoom}/hands/${playerId}`))).val() || [];
      const cardIndex = hand.findIndex(c => c.id === cardId);
      if (cardIndex === -1) return;

      const [card] = hand.splice(cardIndex, 1);
      const discard = (await get(ref(db, `rooms/${currentRoom}/discard/${playerId}`))).val() || [];
      discard.push(card);

      await Promise.all([
        set(ref(db, `rooms/${currentRoom}/hands/${playerId}`), hand),
        set(ref(db, `rooms/${currentRoom}/discard/${playerId}`), discard),
        update(ref(db, `rooms/${currentRoom}/state`), {
          hasDiscardedThisTurn: true,
          lastDiscardPlayer: playerId,
          lastDiscardCard: card
        })
      ]);

      // ‚úÖ Passage automatique au joueur suivant
      const players = Object.keys((await get(ref(db, `rooms/${currentRoom}/players`))).val() || {});
      const nextIndex = (players.indexOf(playerId) + 1) % players.length;

      await Promise.all([
        set(ref(db, `rooms/${currentRoom}/turn`), players[nextIndex]),
        update(ref(db, `rooms/${currentRoom}/state`), {
          hasDrawnOrPicked: false,
          hasDiscardedThisTurn: false
        })
      ]);

      renderHand(hand);
    }

    async function pickFromDiscard() {
      if (isDrawing) return;
      isDrawing = true;
      const discardEl = document.getElementById('discard');
      discardEl.classList.add('no-click');

      try {
        const turn = (await get(ref(db, `rooms/${currentRoom}/turn`))).val();
        if (turn !== playerId) {
          showPopup("Ce n'est pas votre tour.", true);
          return;
        }

        const state = (await get(ref(db, `rooms/${currentRoom}/state`))).val() || {};
        if (state.hasDrawnOrPicked) {
          showPopup("Vous avez d√©j√† pioch√©.", true);
          return;
        }

        const discRef = ref(db, `rooms/${currentRoom}/discard`);
        const snap = await get(discRef);
        const discards = snap.val() || {};

        let ownerId = null, card = null;
        for (let [id, pile] of Object.entries(discards)) {
          if (pile.length && (!card || pile[pile.length - 1].timestamp > card.timestamp)) {
            ownerId = id;
            card = pile[pile.length - 1];
          }
        }
        if (!card) {
          showPopup("Rien √† piocher dans la d√©fausse.", true);
          return;
        }

        // V√©rifier que le joueur est bien le suivant
        const players = Object.keys((await get(ref(db, `rooms/${currentRoom}/players`))).val() || {});
        const nextOfOwner = players[(players.indexOf(ownerId) + 1) % players.length];
        if (playerId !== nextOfOwner) {
          showPopup("Vous ne pouvez pas piocher dans cette d√©fausse.", true);
          return;
        }

        const newPile = discards[ownerId].slice(0, -1);
        const hand = (await get(ref(db, `rooms/${currentRoom}/hands/${playerId}`))).val() || [];

        await Promise.all([
          set(ref(db, `rooms/${currentRoom}/discard/${ownerId}`), newPile),
          set(ref(db, `rooms/${currentRoom}/hands/${playerId}`), [...hand, card]),
          update(ref(db, `rooms/${currentRoom}/state`), { hasDrawnOrPicked: true })
        ]);

      } catch (err) {
        console.error(err);
      } finally {
        isDrawing = false;
        discardEl.classList.remove('no-click');
      }
    }
    async function endTurn() {
      const turn = (await get(ref(db, `rooms/${currentRoom}/turn`))).val();
      if (turn !== playerId) return;

      const state = (await get(ref(db, `rooms/${currentRoom}/state`))).val() || {};
      if (!state.hasDrawnOrPicked || !state.hasDiscardedThisTurn) {
        showPopup("Terminez votre tour (piocher + d√©fausser).");
        return;
      }

      const players = Object.keys((await get(ref(db, `rooms/${currentRoom}/players`))).val() || {});
      const nextIndex = (players.indexOf(playerId) + 1) % players.length;

      await Promise.all([
        set(ref(db, `rooms/${currentRoom}/turn`), players[nextIndex]),
        update(ref(db, `rooms/${currentRoom}/state`), {
          hasDrawnOrPicked: false,
          hasDiscardedThisTurn: false,
          drawCount: 0
        })
      ]);
    }

    // CHAT
    function enableChat() {
      const chatContainer = document.getElementById('chat-container');
      if (!chatContainer) return; // S√©curit√© si l'√©l√©ment n'existe pas
      
      const chatHeader = chatContainer.querySelector('.chat-header');
      if (!chatHeader) return;

      // üîß Ouvre le chat par d√©faut
      chatContainer.classList.remove('collapsed');
      const arrow = chatHeader.querySelector('span');
      if (arrow) arrow.textContent = '‚ñº';

      // üîß Gestion du clic sur l‚Äôen-t√™te
      chatHeader.addEventListener('click', () => {
        chatContainer.classList.toggle('collapsed');
        const arrow = chatHeader.querySelector('span');
        if (arrow) {
          arrow.textContent = chatContainer.classList.contains('collapsed') ? '‚ñ≤' : '‚ñº';
        }
      });

      // üîß Envoi des messages
      document.getElementById('chat-form')?.addEventListener('submit', async (e) => {
        e.preventDefault();
        const message = document.getElementById('chat-input')?.value.trim();
        if (!message) return;

        await set(ref(db, `rooms/${currentRoom}/chat/${Date.now()}`), {
          sender: playerId,
          pseudo: myPseudo,
          message,
          timestamp: Date.now()
        });
        document.getElementById('chat-input').value = '';
      });
    }

    function listenChat(room) {
      onValue(ref(db, `rooms/${room}/chat`), (snapshot) => {
        const messages = snapshot.val() || {};
        const messagesArray = Object.entries(messages)
          .map(([id, msg]) => ({ id, ...msg }))
          .sort((a, b) => a.timestamp - b.timestamp);

        const chatMessages = document.getElementById('chat-messages');
        if (!chatMessages) return; // S√©curit√© si l'√©l√©ment n'existe pas
        
        chatMessages.innerHTML = '';
        messagesArray.forEach(msg => {
          const div = document.createElement('div');
          div.className = `message ${msg.sender === playerId ? 'me' : 'other'}`;
          div.innerHTML = `<b>${msg.pseudo}:</b> ${msg.message}`;
          chatMessages.appendChild(div);
        });
        chatMessages.scrollTop = chatMessages.scrollHeight;
      });
    }

    // UTILITAIRES
    function setupHandDisplayOptions() {
      const buttons = document.querySelectorAll('.hand-display-btn');
      if (!buttons.length) return;
      
      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          const displayType = btn.getAttribute('data-display');
          if (displayType) {
            handDisplayType = displayType;
            const hand = document.getElementById('hand');
            if (hand) {
              hand.className = `player-hand ${displayType}`;
            }
          }
        });
      });
    }

    function enableDragDrop() {
      const handElement = document.getElementById('hand');
      if (!handElement) return;
      
      new Sortable(handElement, {
        animation: 150,
        ghostClass: 'sortable-ghost',
        onEnd: async (evt) => {
          const hand = Array.from(handElement.children).map(el => ({
            id: el.dataset.cardId,
            rank: el.dataset.rank,
            symbol: el.dataset.symbol,
            color: el.dataset.color,
            suit: el.dataset.suit,
            value: parseInt(el.dataset.value, 10)
          }));
          await set(ref(db, `rooms/${currentRoom}/hands/${playerId}`), hand);
        }
      });
    }

    function showPopup(content, isError = false) {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.cssText = `
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.7);
        display: flex; align-items: center; justify-content: center;
        z-index: 9999;
      `;
      modal.innerHTML = `
        <div class="modal-content" style="background: white; padding: 2rem; border-radius: 12px; max-width: 400px; text-align: center;">
          ${content}
          <button class="modal-close" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #3498db; color: white; border: none; border-radius: 6px;">OK</button>
        </div>
      `;
      document.body.appendChild(modal);
      modal.querySelector('.modal-close').addEventListener('click', () => modal.remove());
    }

    function showGlobalPopup(message, cards = null) {
      const overlay = document.createElement('div');
      overlay.className = 'global-popup-overlay';
      overlay.innerHTML = `
        <div class="global-popup-box">
          <div class="notif-message">${message}</div>
          ${cards ? '<div class="notif-cards">' + cards.map(c => `
            <div class="card ${c.color}">
              <div class="corner top"><span>${c.rank}</span><span>${c.symbol}</span></div>
              <div class="suit main">${c.symbol}</div>
            </div>
          `).join('') + '</div>' : ''}
        </div>
      `;
      document.body.appendChild(overlay);
      setTimeout(() => overlay.remove(), 4000);
      overlay.addEventListener('click', () => overlay.remove());
    }

    window.addEventListener('resize', () => {
      if (handDisplayType === 'semi-circle') {
        setTimeout(arrangeCardsInSemiCircle, 100);
      }
    });

    // Gestion du bouton "Terminer le tour"
    document.getElementById('endTurnBtn')?.addEventListener('click', endTurn);

    // Gestion des d√©clarations
    document.getElementById('declare7N')?.addEventListener('click', declare7Naturel);
    document.getElementById('declareWin')?.addEventListener('click', declareWin);
  </script>
</body>
</html>
