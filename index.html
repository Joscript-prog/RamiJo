<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rami en ligne - Jeu de cartes multijoueur</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Poppins:wght@600&display=swap" />
  <style>:root { --primary:#2c3e50; --secondary:#3498db; --accent:#e74c3c; --success:#27ae60; --warning:#f39c12; --danger:#e74c3c; --text:#2d3436; --text-light:#7f8c8d; --text-white:#ffffff; --bg:#f8f9fa; --bg-dark:#1a1a1a; --felt-green:#0d5016; --felt-green-light:#1a7a28; --card-white:#ffffff; --card-red:#e74c3c; --card-black:#2c3e50; --shadow-sm:0 2px 8px rgba(0,0,0,0.1); --shadow-md:0 4px 16px rgba(0,0,0,0.15); --shadow-lg:0 8px 32px rgba(0,0,0,0.2); --shadow-xl:0 16px 64px rgba(0,0,0,0.25); --shadow-glow:0 0 20px rgba(52,152,219,0.3); --radius:12px; --radius-sm:8px; --radius-lg:16px; --transition:all .3s cubic-bezier(.4,0,.2,1); --transition-bounce:all .4s cubic-bezier(.68,-.55,.265,1.55); --card-width:140px; --card-height:210px; --hand-bottom:40px; --chat-width:320px; --chat-height:280px; --gradient-primary:linear-gradient(135deg,#3498db 0%,#2980b9 100%); --gradient-success:linear-gradient(135deg,#27ae60 0%,#229954 100%); --gradient-felt:linear-gradient(135deg,#0d5016 0%,#1a7a28 50%,#0d5016 100%); } *{margin:0;padding:0;box-sizing:border-box;touch-action:manipulation} body{font-family:'Roboto',-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;color:var(--text);line-height:1.6;min-height:100vh;overflow-x:hidden;background:var(--felt-green);background-image:var(--gradient-felt)} #game{display:none;flex-direction:column;height:100vh} .menu-overlay{position:fixed;inset:0;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);display:flex;justify-content:center;align-items:center;z-index:1000;animation:fadeIn .6s ease-out;padding:1rem} .menu-content{background:rgba(255,255,255,.95);backdrop-filter:blur(20px);padding:2rem;border-radius:var(--radius-lg);box-shadow:var(--shadow-xl);text-align:center;max-width:min(500px,90vw);width:100%;border:1px solid rgba(255,255,255,.2);animation:slideUp .6s ease-out} .menu-content h1{font-family:'Poppins',sans-serif;font-size:clamp(2rem,5vw,2.5rem);color:var(--primary);margin-bottom:1.5rem;text-shadow:0 2px 10px rgba(0,0,0,.1);background:var(--gradient-primary);-webkit-background-clip:text;-webkit-text-fill-color:transparent} .menu-section{margin:1.5rem 0} .menu-section h2{font-size:clamp(1.1rem,3vw,1.3rem);color:var(--text);margin-bottom:.75rem;font-weight:500} .separator{margin:1.5rem 0;position:relative;color:var(--text-light);font-weight:500;background:rgba(255,255,255,.95);padding:0 1rem;display:inline-block} .separator::before{content:'';position:absolute;top:50%;left:-30px;right:-30px;height:1px;background:linear-gradient(to right,transparent,var(--text-light),transparent);z-index:-1} .join-form{display:flex;gap:.75rem;flex-wrap:wrap;justify-content:center} .room-input{flex:1;min-width:200px;padding:.75rem 1rem;border:2px solid #e0e0e0;border-radius:var(--radius);font-size:1rem;transition:var(--transition);background:rgba(255,255,255,.9);backdrop-filter:blur(10px)} .room-input:focus{outline:2px solid var(--secondary);outline-offset:2px;box-shadow:0 0 0 3px rgba(52,152,219,.1);transform:scale(1.02)} .btn{padding:.75rem 1.5rem;border:none;border-radius:var(--radius);font-size:1rem;font-weight:500;cursor:pointer;transition:var(--transition-bounce);position:relative;overflow:hidden;text-transform:uppercase;letter-spacing:.5px;width:100%;max-width:300px} .btn::before{content:'';position:absolute;top:50%;left:50%;width:0;height:0;background:rgba(255,255,255,.3);border-radius:50%;transform:translate(-50%,-50%);transition:width .6s,height .6s} .btn:hover::before{width:300px;height:300px} .btn-primary{background:var(--gradient-primary);color:var(--text-white);box-shadow:var(--shadow-md)} .btn-primary:focus{outline:2px solid var(--accent);outline-offset:2px} .btn-primary:hover{transform:translateY(-2px);box-shadow:var(--shadow-lg),var(--shadow-glow)} .btn-secondary{background:var(--gradient-success);color:var(--text-white);box-shadow:var(--shadow-md)} .btn-secondary:focus{outline:2px solid var(--accent);outline-offset:2px} .btn-secondary:hover{transform:translateY(-2px);box-shadow:var(--shadow-lg),0 0 20px rgba(39,174,96,.3)} .btn:disabled{background:#bdc3c7;cursor:not-allowed} .game-header{position:fixed;top:0;left:0;width:100%;display:flex;justify-content:space-between;align-items:center;padding:1rem;background:rgba(0,0,0,.7);backdrop-filter:blur(10px);z-index:100;color:white} .header-left,.header-right{display:flex;align-items:center;gap:1rem} .game-play-area{padding-top:60px;height:calc(100vh - 60px);display:flex;flex-direction:column;position:relative} .game-table-container{flex:1;display:flex;flex-direction:column;position:relative;padding:20px} .table-center{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);display:flex;flex-direction:column;align-items:center;gap:1rem} #joker{position:fixed;top:70px;left:20px;z-index:200;display:flex;flex-direction:column;align-items:center;gap:.5rem} .joker-label{color:var(--text-white);font-weight:600;font-size:1rem;text-align:center;background:rgba(0,0,0,.3);padding:.5rem;border-radius:var(--radius);backdrop-filter:blur(10px)} .deck-area{display:flex;flex-direction:column;align-items:center;gap:.75rem} .deck-pile{position:relative;cursor:pointer;transition:var(--transition)} .deck-pile:hover{transform:translateY(-5px);filter:brightness(1.1)} .deck-label{color:var(--text-white);font-weight:600;font-size:clamp(1rem,2.5vw,1.2rem);text-align:center;background:rgba(0,0,0,.3);padding:.75rem 1.25rem;border-radius:var(--radius);backdrop-filter:blur(10px)} .card{width:var(--card-width);height:var(--card-height);border-radius:var(--radius-sm);box-shadow:var(--shadow-md);position:relative;cursor:pointer;transition:var(--transition);border:1px solid #e0e0e0;display:flex;flex-direction:column;justify-content:space-between;padding:.75rem;font-weight:700;user-select:none;background:var(--card-white)} .card:hover{transform:translateY(-8px);box-shadow:var(--shadow-lg);z-index:10} .card.back{background:linear-gradient(135deg,#1e3a8a 0%,#3b82f6 50%,#1e3a8a 100%);border:2px solid #1e40af} .card.back::before{content:'ðŸ‚ ';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:3.5rem;color:white;text-shadow:0 2px 4px rgba(0,0,0,.3)} .corner{font-size:1.2rem;line-height:1;display:flex;flex-direction:column;align-items:center;color:var(--card-black)} .corner.top{align-self:flex-start} .corner.bottom{align-self:flex-end;transform:rotate(180deg)} .card.red .corner{color:var(--card-red)} .suit.main{font-size:6rem;line-height:1;text-align:center;flex-grow:1;display:flex;align-items:center;justify-content:center;color:var(--card-black)} .card.red .suit.main{color:var(--card-red)} #players-container{display:flex;justify-content:space-around;padding:20px;flex-wrap:wrap;gap:20px;z-index:30;position:relative} .player-slot{display:flex;flex-direction:column;align-items:center;gap:10px;min-width:180px;position:relative} .player-info{background:rgba(255,255,255,.1);backdrop-filter:blur(10px);padding:.75rem 1rem;border-radius:var(--radius);color:var(--text-white);font-weight:500;border:1px solid rgba(255,255,255,.2);min-width:150px;text-align:center;font-size:clamp(1rem,2.5vw,1.1rem);transition:var(--transition)} .player-info.active{background:rgba(52,152,219,.3);border-color:rgba(52,152,219,.5);box-shadow:var(--shadow-glow);transform:scale(1.05)} .player-name{font-weight:600;margin-bottom:5px;font-size:1.1em} .player-hand-count{font-size:.9em;opacity:.9} .player-discard{min-height:50px;min-width:100px;display:flex;justify-content:center;align-items:center;margin-top:10px;position:relative;z-index:10} .player-discard .card{width:80px;height:120px;cursor:pointer;position:relative;z-index:10} .player-discard.previous{border:2px dashed rgba(52,152,219,.6);border-radius:var(--radius-sm);padding:5px;box-shadow:0 0 10px rgba(52,152,219,.3);z-index:15} .player-discard.previous .card{transform:scale(1.1);box-shadow:0 0 15px rgba(52,152,219,.5)} #hand-container{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);width:auto;z-index:100;background:transparent;padding:10px} #hand{display:flex;justify-content:center;gap:0;padding:0;min-width:content;width:fit-content;margin:0 auto;position:relative;min-height:var(--card-height)} #hand .card{margin-right:-80px;transition:var(--transition);cursor:grab;position:relative} #hand .card:last-child{margin-right:0;z-index:5} #hand .card:hover{z-index:10;transform:translateY(-15px)} #hand .card.sortable-ghost{opacity:.2} .player-discard .card.clickable{cursor:pointer;border:2px solid #00f;transition:transform .2s} .player-discard .card.clickable:hover{transform:scale(1.05)} .game-controls{position:fixed;top:70px;right:20px;width:240px;padding:1rem;background:rgba(0,0,0,.7);backdrop-filter:blur(10px);border-radius:var(--radius);display:flex;flex-direction:column;gap:.75rem;z-index:40;overflow-y:auto} .btn-special{padding:.75rem;background:var(--gradient-primary);color:var(--text-white);border:none;border-radius:var(--radius);cursor:pointer;font-weight:500;transition:var(--transition);text-transform:uppercase;font-size:clamp(.9rem,2vw,1rem)} .btn-special:hover:not(:disabled){transform:translateY(-2px);box-shadow:var(--shadow-md)} .btn-special:disabled{background:#6c757d;cursor:not-allowed;opacity:.6} .btn-action{padding:.75rem;background:var(--gradient-success);color:var(--text-white);border:none;border-radius:var(--radius);cursor:pointer;font-weight:600;transition:var(--transition);text-transform:uppercase;font-size:clamp(1rem,2.5vw,1.1rem);margin-top:auto} .btn-action:hover:not(:disabled){transform:translateY(-2px);box-shadow:var(--shadow-md)} .btn-action:disabled{background:#6c757d;cursor:not-allowed;opacity:.6} .modal{position:fixed;z-index:10000;left:0;top:0;width:100%;height:100%;background-color:rgba(0,0,0,.6);display:flex;justify-content:center;align-items:center;backdrop-filter:blur(5px);animation:fadeIn .3s ease-out} .modal-content{background-color:var(--bg);padding:30px;border-radius:var(--radius);box-shadow:var(--shadow-xl);text-align:center;max-width:400px;width:90%;position:relative;animation:slideUp .3s ease-out} .modal-content input{width:calc(100% - 20px);padding:10px;margin-bottom:15px;border:1px solid #ccc;border-radius:var(--radius-sm);font-size:1rem} .modal-close{position:absolute;top:10px;right:15px;font-size:24px;font-weight:bold;color:var(--text-light);cursor:pointer;background:none;border:none} .modal-close:hover{color:var(--accent)} .global-popup-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.4);display:flex;justify-content:center;align-items:center;z-index:9999;animation:fadeIn .3s ease-out;pointer-events:auto} .global-popup-box{background:rgba(255,255,255,.95);backdrop-filter:blur(20px);padding:2rem;border-radius:var(--radius-lg);box-shadow:var(--shadow-xl);text-align:center;max-width:min(500px,90vw);width:100%;border:1px solid rgba(255,255,255,.2);animation:slideUp .3s ease-out;color:var(--primary)} .notif-message{font-family:'Poppins',sans-serif;font-size:clamp(1.2rem,3vw,1.5rem);margin-bottom:1rem;color:var(--text)} .notif-cards{display:flex;justify-content:center;gap:10px;flex-wrap:wrap} .notif-cards .card{width:80px;height:120px;font-size:.8rem} .notif-cards .card .suit.main{font-size:2.5rem} #chat-container{position:fixed;bottom:0;right:20px;width:var(--chat-width);height:var(--chat-height);background:rgba(0,0,0,.6);backdrop-filter:blur(10px);border-top-left-radius:var(--radius);border-top-right-radius:var(--radius);box-shadow:var(--shadow-lg);display:flex;flex-direction:column;z-index:100;overflow:hidden} .chat-header{background:var(--gradient-primary);padding:.75rem 1rem;color:var(--text-white);display:flex;justify-content:space-between;align-items:center;cursor:pointer;font-family:'Poppins',sans-serif;font-size:1.1rem;font-weight:500} .chat-header span{transition:transform .3s ease} #chat-container.collapsed{height:40px} #chat-container.collapsed .chat-content{display:none} #chat-container.collapsed .chat-header span{transform:rotate(180deg)} .chat-content{flex-grow:1;display:flex;flex-direction:column;padding:.75rem;overflow-y:auto;background:rgba(255,255,255,.1)} #chat-messages{flex-grow:1;overflow-y:auto;margin-bottom:.75rem;color:var(--text-white);font-size:.9rem;line-height:1.4;word-wrap:break-word} .message.me{text-align:right;color:var(--accent)} .message.other{text-align:left;color:var(--secondary)} .chat-form{display:flex;gap:.5rem} #chat-input{flex-grow:1;padding:.5rem;border:1px solid rgba(255,255,255,.3);border-radius:var(--radius-sm);background:rgba(255,255,255,.1);color:var(--text-white);font-size:.9rem} #chat-input::placeholder{color:rgba(255,255,255,.7)} #chat-input:focus{outline:none;border-color:var(--secondary)} .chat-form button{padding:.5rem 1rem;background:var(--gradient-success);color:var(--text-white);border:none;border-radius:var(--radius-sm);cursor:pointer;transition:var(--transition)} .chat-form button:hover{filter:brightness(1.1)} .hand-display-options{position:absolute;top:-50px;right:20px;display:flex;gap:.5rem;z-index:70} .hand-display-btn{background:rgba(255,255,255,.2);border:none;border-radius:50%;width:36px;height:36px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:18px;transition:var(--transition)} .hand-display-btn:hover{background:var(--gradient-primary);color:white} .hand-display-btn.active{background:var(--gradient-success);color:white} @keyframes fadeIn{from{opacity:0}to{opacity:1}} @keyframes slideUp{from{transform:translateY(50px);opacity:0}to{transform:translateY(0);opacity:1}} @media (max-width:768px){:root{--card-width:100px;--card-height:150px;--chat-width:100%;--chat-height:250px} .menu-content{padding:1.5rem} .btn{font-size:.9rem;padding:.6rem 1rem} .game-header{flex-direction:column;gap:.5rem} .header-left,.header-right{width:100%;justify-content:center} .game-controls{position:fixed;top:80px;right:20px;z-index:150} #hand .card{margin-right:-50px} .hand-display-options{top:-40px;right:10px} #chat-container{right:0;border-radius:0} #joker{top:60px;left:10px} }
</style>
</head>
<body>
  <div id="menu" class="menu-overlay">
    <div class="menu-content">
      <h1>Bienvenue au Rami !</h1>
      <div class="menu-section">
        <button id="createRoom" class="btn btn-primary">CrÃ©er une nouvelle partie</button>
      </div>
      <div class="separator">OU</div>
      <div class="menu-section">
        <h2>Rejoindre une partie</h2>
        <div class="join-form">
          <input id="roomCodeInput" class="room-input" type="text" maxlength="7" placeholder="Code de partie (RAMI123)" pattern="RAMI\d{3}" />
          <button id="joinRoom" class="btn btn-secondary">Rejoindre</button>
        </div>
      </div>
    </div>
  </div>

  <div id="game" style="display: none;">
    <header class="game-header">
      <div class="header-left">
        <span id="status">PrÃ©paration de la partie...</span>
        <span id="roomCodeDisplay"></span>
      </div>
      <div class="header-right">
        <div class="hand-display-options">
          <button class="hand-display-btn" data-display="horizontal">â†”</button>
          <button class="hand-display-btn" data-display="vertical">â†•</button>
        </div>
      </div>
    </header>

    <div class="game-play-area">
      <aside class="game-controls">
        <button id="startGameBtn" class="btn-action" style="display: none;">DÃ©marrer la partie</button>
        <button id="sortHandBtn" class="btn-special">Ranger les cartes</button>
        <button id="endTurnBtn" class="btn-action" disabled>Terminer le tour</button>
        <button id="declare7N" class="btn-special" disabled>DÃ©clarer 7 Naturel</button>
        <button id="declareWin" class="btn-special" disabled>DÃ©clarer Victoire</button>
        <button id="newGameBtn" class="btn btn-warning">ðŸ”„ Nouvelle Partie</button>
        <span id="roundIndicator">Manche 1</span>
      </aside>

      <div id="joker">
        <div class="joker-label">Joker</div>
        <div class="card back"></div>
      </div>

      <div id="players-container"></div>

      <div class="game-table-container">
        <div class="table-center">
          <div class="deck-area">
            <div id="deck" class="deck-pile clickable"><div class="card back"></div></div>
            <div class="deck-label">Pioche</div>
          </div>
        </div>
      </div>

      <div id="hand-container">
        <div id="hand" class="player-hand horizontal"></div>
      </div>

      <div id="chat-container">
        <div class="chat-header"><h3>Chat</h3><span>â–¼</span></div>
        <div class="chat-content">
          <div id="chat-messages"></div>
          <form id="chat-form">
            <input id="chat-input" type="text" placeholder="Messageâ€¦" autocomplete="off" />
            <button type="submit">Envoyer</button>
          </form>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // ===== Utilitaire : marquer les jokers sur un tableau de cartes =====
    function markJokersOnCards(cards, jokerIds) {
      if (!Array.isArray(cards)) return [];
      return cards.map(c => ({
        ...c,
        isJoker: jokerIds.includes(c.id)
      }));
    }

    import { db, ref, push, onChildAdded, set, update, get, onValue } from './firebase.js';
    import Sortable from 'https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/modular/sortable.esm.js';

    let myPseudo = '';
    const playerId = 'player_' + Math.floor(Math.random() * 10000);
    const playersMap = {};
    let currentRoom = '';
    let isDrawing = false;
    let hasDrawnOrPicked = false;
    let hasDiscardedThisTurn = false;
    let handDisplayType = 'horizontal';
    let currentHand = [];
    let gameRounds = 0;
    let jokerSet = [];

    const Rules = {
      isThreeOfKind(combo) {
        if (combo.length < 3 || combo.length > 4) return false;
        const vals = combo.map(c => c.value);
        return vals.every(v => v === vals[0]);
      },
      isSequence(combo) {
        if (combo.length < 3 || combo.length > 4) return false;
        const suits = new Set(combo.map(c => c.suit));
        if (suits.size !== 1) return false;
        const sorted = combo.map(c => c.value).sort((a, b) => a - b);
        for (let i = 1; i < sorted.length; i++) {
          if (sorted[i] !== sorted[i - 1] + 1) return false;
        }
        return true;
      },
      combinations(arr, k) {
        const result = [];
        function backtrack(start, comb) {
          if (comb.length === k) {
            result.push(comb.slice());
            return;
          }
          for (let i = start; i < arr.length; i++) {
            comb.push(arr[i]);
            backtrack(i + 1, comb);
            comb.pop();
          }
        }
        backtrack(0, []);
        return result;
      },
      getNaturalFormations(hand) {
        const nonJokers = hand.filter(c => !c.isJoker);
        const formations = [];
        [2, 3, 4].forEach(size => {
          this.combinations(nonJokers, size).forEach(combo => {
            if (combo.length >= 2) formations.push(combo);
          });
        });
        return formations;
      },
      assignJokers(formations, jokers) {
        const results = [];
        function backtrack(idx, current) {
          if (idx === jokers.length) {
            results.push(current.map(f => f.slice()));
            return;
          }
          formations.forEach((_, i) => {
            if (current[i].length < 4) {
              current[i].push(jokers[idx]);
              backtrack(idx + 1, current);
              current[i].pop();
            }
          });
        }
        backtrack(0, formations.map(f => f.slice()));
        return results;
      },
      hasSequenceAndKind(forms) {
        let seq = false, kind = false;
        forms.forEach(f => {
          if (this.isSequence(f)) seq = true;
          if (this.isThreeOfKind(f)) kind = true;
        });
        return seq && kind;
      },
      detectSevenNatural(forms) {
        const suites = forms.filter(f => f.length >= 3 && this.isSequence(f) && f.every(c => !c.isJoker));
        const brelans = forms.filter(f => f.length >= 3 && this.isThreeOfKind(f) && f.every(c => !c.isJoker));
        for (const s of suites) {
          const sIds = new Set(s.map(c => c.id));
          for (const b of brelans) {
            if (b.some(c => sIds.has(c.id))) continue;
            const total = s.length + b.length;
            if (total === 7) return true;
          }
        }
        return false;
      },
      validateWinHand(hand, hasDeclared7N, deckEmpty) {
        const jokers = hand.filter(c => c.isJoker);
        const naturalForms = this.getNaturalFormations(hand);
        const assignments = this.assignJokers(naturalForms, jokers);
        let bestResult = { isWin: false, pointsEarned: 0 };
        assignments.forEach(forms => {
          this.combinations(forms, 4).forEach(group => {
            const lengths = group.map(f => f.length).sort((a, b) => b - a);
            if (lengths[0] === 4 && lengths[1] === 3 && lengths[2] === 3 && lengths[3] === 3) {
              if (!this.hasSequenceAndKind(group)) return;
              const is7N = this.detectSevenNatural(group);
              let winType, pts, rematch;
              if (is7N && !hasDeclared7N) {
                winType = 'large+small'; pts = 1.5; rematch = false;
              } else if (is7N && hasDeclared7N) {
                winType = 'large'; pts = 1; rematch = false;
              } else {
                winType = 'large'; pts = deckEmpty ? 2 : 1; rematch = !hasDeclared7N;
              }
              if (pts > bestResult.pointsEarned) {
                bestResult = { isWin: true, winType, pointsEarned: pts, triggerRematch: rematch, bestGroup: group };
              }
            }
          });
        });
        return bestResult;
      }
    };

    function getCardValue(rank) {
      switch (rank) {
        case 'A': return 1;
        case 'J': return 11;
        case 'Q': return 12;
        case 'K': return 13;
        default: return parseInt(rank, 10);
      }
    }

    function createDeck() {
      const suits = [
        { suit: 'Coeurs', symbol: 'â™¥', color: 'red' },
        { suit: 'Carreaux', symbol: 'â™¦', color: 'red' },
        { suit: 'TrÃ¨fles', symbol: 'â™£', color: 'black' },
        { suit: 'Piques', symbol: 'â™ ', color: 'black' }
      ];
      const ranks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
      const deck = [];
      for (let d = 0; d < 2; d++) {
        suits.forEach(suitObj => {
          ranks.forEach(rank => {
            deck.push({
              suit: suitObj.suit,
              symbol: suitObj.symbol,
              color: suitObj.color,
              rank,
              value: getCardValue(rank),
              id: `${rank}${suitObj.symbol}${d}`,
              isJoker: false
            });
          });
        });
      }
      return deck;
    }

    function shuffle(array) {
      let currentIndex = array.length, randomIndex;
      while (currentIndex !== 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
      }
      return array;
    }

    async function dealCards(roomId, playerIds) {
      let deck = shuffle(createDeck());
      const hands = {};
      playerIds.forEach(pid => {
        hands[pid] = deck.splice(0, 13);
      });
      const revealed = deck.shift();
      jokerSet = deck.filter(c => c.value === revealed.value && c.color !== revealed.color).map(c => c.id);
      playerIds.forEach(pid => {
        hands[pid] = markJokersOnCards(hands[pid], jokerSet);
      });
      deck = markJokersOnCards(deck, jokerSet);
      await Promise.all([
        set(ref(db, `rooms/${roomId}/deck`), deck),
        set(ref(db, `rooms/${roomId}/jokerCard`), revealed),
        set(ref(db, `rooms/${roomId}/jokerSet`), jokerSet),
        set(ref(db, `rooms/${roomId}/hands`), hands),
        set(ref(db, `rooms/${roomId}/discard`), {}),
        set(ref(db, `rooms/${roomId}/scores`), {}),
        set(ref(db, `rooms/${roomId}/state`), {
          started: false,
          drawCount: 0,
          hasDrawnOrPicked: false,
          hasDiscardedThisTurn: false,
          sevenDeclared: false,
          winDeclared: false,
          roundOver: false,
          gameRound: gameRounds
        }),
        set(ref(db, `rooms/${roomId}/chat`), {})
      ]);
    }

    async function askPseudo() {
      return new Promise(resolve => {
        showPopup(`
          <h3>Entrez votre pseudo</h3>
          <input id="pseudoInput" type="text" placeholder="Votre pseudo" maxlength="15" style="width: 100%; padding: 0.5rem; margin: 1rem 0;" />
          <button id="pseudoSubmit" class="btn btn-primary">Valider</button>
        `);
        document.getElementById('pseudoSubmit').addEventListener('click', () => {
          const val = document.getElementById('pseudoInput').value.trim();
          myPseudo = val || 'Joueur';
          document.querySelector('.modal')?.remove();
          resolve();
        });
      });
    }

    async function createRoom() {
      await askPseudo();
      const roomCode = 'RAMI' + Math.floor(100 + Math.random() * 900);
      currentRoom = roomCode;
      gameRounds = 0;
      showPopup(`
        <h3>ðŸŽ‰ Salle crÃ©Ã©e</h3>
        <p>Partage ce code :</p>
        <b style="font-size: 1.5rem; color: #e74c3c;">${roomCode}</b>
        <br><br>
        <button onclick="navigator.clipboard.writeText('${roomCode}')" class="btn btn-secondary">ðŸ“‹ Copier</button>
        <br><br>
        <button class="btn btn-primary modal-close">Continuer</button>
      `);
      await set(ref(db, `rooms/${roomCode}/players/${playerId}`), {
        pseudo: myPseudo,
        hasDeclared7N: false,
        score: 0,
        isSpectator: false,
        sevenNPoints: 0,
        totalScore: 0
      });
      await set(ref(db, `rooms/${roomCode}/creator`), playerId);
      setupListeners(roomCode);
      document.getElementById('menu').style.display = 'none';
      document.getElementById('game').style.display = 'flex';
    }

    async function joinRoom() {
      const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
      if (!/^RAMI\d{3}$/.test(roomCode)) return showPopup("Code invalide (format: RAMI123)", true);
      const snapshot = await get(ref(db, `rooms/${roomCode}`));
      if (!snapshot.exists()) return showPopup("Salle introuvable", true);
      await askPseudo();
      await set(ref(db, `rooms/${roomCode}/players/${playerId}`), {
        pseudo: myPseudo,
        hasDeclared7N: false,
        score: 0,
        isSpectator: false,
        sevenNPoints: 0,
        totalScore: 0
      });
      currentRoom = roomCode;
      setupListeners(roomCode);
      document.getElementById('menu').style.display = 'none';
      document.getElementById('game').style.display = 'flex';
    }

    function setupListeners(roomCode) {
      listenPlayers(roomCode);
      listenHand(roomCode);
      listenTurn(roomCode);
      listenJokerCard(roomCode);
      listenDiscard(roomCode);
      listenChat(roomCode);
      onChildAdded(ref(db, `rooms/${roomCode}/popups`), snap => {
        const data = snap.val();
        const pseudo = playersMap[data.player]?.pseudo || data.player;
        const msg = data.type === 'win' ? `ðŸ† ${pseudo} gagne !` : `ðŸŽ‰ ${pseudo} dÃ©clare 7N !`;
        showGlobalPopup(msg, data.formations?.flat?.() || null);
      });
      document.getElementById('startGameBtn')?.addEventListener('click', startGame);
      document.getElementById('deck')?.addEventListener('click', drawCard);
      setupHandDisplayOptions();
      enableChat();
      enableDragDrop();
      document.getElementById('discard')?.addEventListener('click', () => {
        if (!currentRoom) return;
        pickFromDiscard();
      });
      document.getElementById('sortHandBtn')?.addEventListener('click', sortHandByFormation);
      document.addEventListener('click', (e) => {
        const discardSlot = e.target.closest('.player-discard');
        if (!discardSlot) return;
        const ownerId = discardSlot.dataset.owner;
        if (!ownerId || ownerId === playerId) return;
        handlePickFromPreviousDiscard(ownerId);
      });
    }

    async function startGame() {
      const playersSnap = await get(ref(db, `rooms/${currentRoom}/players`));
      const playerIds = Object.keys(playersSnap.val() || {});
      await dealCards(currentRoom, playerIds);
      await set(ref(db, `rooms/${currentRoom}/turn`), playerIds[0]);
      await update(ref(db, `rooms/${currentRoom}/state`), {
        started: true,
        sevenDeclared: false,
        winDeclared: false,
        roundOver: false,
        gameRound: 0,
        drawCount: 0,
        hasDrawnOrPicked: false,
        hasDiscardedThisTurn: false
      });
      const updates = {};
      playerIds.forEach(id => {
        updates[`${id}/hasDeclared7N`] = false;
        updates[`${id}/score`] = 0;
        updates[`${id}/sevenNPoints`] = 0;
        updates[`${id}/totalScore`] = 0;
      });
      await update(ref(db, `rooms/${currentRoom}/players`), updates);
      document.getElementById('startGameBtn').style.display = 'none';
    }

    async function declare7Naturel() {
      const stateSnap = await get(ref(db, `rooms/${currentRoom}/state`));
      const state = stateSnap.val() || {};
      if (state.sevenDeclared) {
        showPopup("Un 7N a dÃ©jÃ  Ã©tÃ© dÃ©clarÃ©.");
        return;
      }
      const [handSnap, jokerSnap] = await Promise.all([
        get(ref(db, `rooms/${currentRoom}/hands/${playerId}`)),
        get(ref(db, `rooms/${currentRoom}/jokerSet`))
      ]);
      const hand = handSnap.val() || [];
      const jokerIds = jokerSnap.val() || [];
      const cards = markJokersOnCards(hand, jokerIds);
      const naturalForms = Rules.getNaturalFormations(cards);
      if (!Rules.detectSevenNatural(naturalForms)) {
        showPopup("Pas de 7 Naturel valide.");
        return;
      }
      const points = gameRounds === 0 ? 0.5 : 1.0;
      await Promise.all([
        update(ref(db, `rooms/${currentRoom}/players/${playerId}`), {
          hasDeclared7N: true,
          sevenNPoints: points
        }),
        update(ref(db, `rooms/${currentRoom}/state`), {
          sevenDeclared: true,
          sevenDeclarant: playerId
        })
      ]);
      showGlobalPopup(`ðŸŽ‰ ${myPseudo} dÃ©clare 7N (+${points} pts)`, naturalForms.flat());
      await push(ref(db, `rooms/${currentRoom}/popups`), {
        type: '7N',
        player: playerId,
        formations: naturalForms,
        timestamp: Date.now()
      });
    }

    async function declareWin() {
      const [handSnap, stateSnap, deckSnap, jokerSnap] = await Promise.all([
        get(ref(db, `rooms/${currentRoom}/hands/${playerId}`)),
        get(ref(db, `rooms/${currentRoom}/state`)),
        get(ref(db, `rooms/${currentRoom}/deck`)),
        get(ref(db, `rooms/${currentRoom}/jokerSet`))
      ]);
      const hand = handSnap.val() || [];
      const state = stateSnap.val() || {};
      const deckCards = deckSnap.val() || [];
      const jokerIds = jokerSnap.val() || [];
      const hasDeclared7N = state.sevenDeclared;
      const deckEmpty = deckCards.length === 0;
      const cards = markJokersOnCards(hand, jokerIds);
      const result = Rules.validateWinHand(cards, hasDeclared7N, deckEmpty);
      if (!result.isWin) {
        showPopup("Main non valide pour la victoire.", true);
        return;
      }
      const sevenNPoints = (await get(ref(db, `rooms/${currentRoom}/players/${playerId}/sevenNPoints`))).val() || 0;
      const totalScore = sevenNPoints + result.pointsEarned;
      await Promise.all([
        update(ref(db, `rooms/${currentRoom}/players/${playerId}`), {
          totalScore,
          winBonus: result.pointsEarned
        }),
        update(ref(db, `rooms/${currentRoom}/state`), {
          winDeclared: true,
          winner: playerId,
          winnerName: myPseudo
        })
      ]);
      const cardsToShow = result.bestGroup?.flat() || cards;
      showGlobalPopup(`ðŸ† ${myPseudo} gagne ! (+${result.pointsEarned} pts)`, cardsToShow);
      await push(ref(db, `rooms/${currentRoom}/popups`), {
        type: 'win',
        player: playerId,
        formations: result.bestGroup || [],
        timestamp: Date.now()
      });
      if (result.triggerRematch) {
        showPopup("âš ï¸ DeuxiÃ¨me manche pour le 7N commence !");
        gameRounds += 1;
        const playersSnap = await get(ref(db, `rooms/${currentRoom}/players`));
        const playerIds = Object.keys(playersSnap.val() || {});
        await update(ref(db, `rooms/${currentRoom}/state`), {
          sevenDeclared: false,
          winDeclared: false,
          gameRound: gameRounds,
          drawCount: 0,
          hasDrawnOrPicked: false,
          hasDiscardedThisTurn: false
        });
        const resetPlayers = {};
        playerIds.forEach(pid => {
          resetPlayers[`${pid}/hasDeclared7N`] = false;
          resetPlayers[`${pid}/sevenNPoints`] = 0;
        });
        await update(ref(db, `rooms/${currentRoom}/players`), resetPlayers);
        await dealCards(currentRoom, playerIds);
        await set(ref(db, `rooms/${currentRoom}/turn`), playerIds[0]);
        const roundEl = document.getElementById('roundIndicator');
        if (roundEl) roundEl.textContent = `Manche ${gameRounds + 1}`;
      }
    }

    async function startNewGame() {
      gameRounds = 0;
      const playersSnap = await get(ref(db, `rooms/${currentRoom}/players`));
      const playerIds = Object.keys(playersSnap.val() || {});
      await dealCards(currentRoom, playerIds);
      await set(ref(db, `rooms/${currentRoom}/state`), {
        started: true,
        drawCount: 0,
        hasDrawnOrPicked: false,
        hasDiscardedThisTurn: false,
        sevenDeclared: false,
        winDeclared: false,
        roundOver: false,
        gameRound: 0
      });
      const resetPlayers = {};
      playerIds.forEach(pid => {
        resetPlayers[`${pid}/hasDeclared7N`] = false;
        resetPlayers[`${pid}/sevenNPoints`] = 0;
        resetPlayers[`${pid}/score`] = 0;
        resetPlayers[`${pid}/totalScore`] = 0;
      });
      await update(ref(db, `rooms/${currentRoom}/players`), resetPlayers);
      await set(ref(db, `rooms/${currentRoom}/turn`), playerIds[0]);
      const roundEl = document.getElementById('roundIndicator');
      if (roundEl) roundEl.textContent = `Manche 1`;
    }

    function renderHand(hand) {
      const handDiv = document.getElementById('hand');
      if (!handDiv) return;
      handDiv.innerHTML = '';
      hand.forEach(card => {
        const div = document.createElement('div');
        div.className = `card ${card.color}`;
        div.dataset.cardId = card.id;
        div.dataset.rank = card.rank;
        div.dataset.symbol = card.symbol;
        div.dataset.color = card.color;
        div.dataset.suit = card.suit;
        div.dataset.value = card.value;
        div.innerHTML = `
          <div class="corner top">${card.rank}${card.symbol}</div>
          <div class="suit main">${card.symbol}</div>
        `;
        div.addEventListener('dblclick', () => discardCard(card.id));
        handDiv.appendChild(div);
      });
    }

    function createCardElement(card) {
      const div = document.createElement('div');
      div.className = `card ${card.color}`;
      div.dataset.cardId = card.id;
      div.dataset.rank = card.rank;
      div.dataset.symbol = card.symbol;
      div.dataset.color = card.color;
      div.dataset.suit = card.suit;
      div.dataset.value = card.value;
      div.innerHTML = `
        <div class="corner top">${card.rank}${card.symbol}</div>
        <div class="suit main">${card.symbol}</div>
      `;
      return div;
    }

    async function renderDiscardPiles(discards) {
      const [turnSnap, playersSnap] = await Promise.all([
        get(ref(db, `rooms/${currentRoom}/turn`)),
        get(ref(db, `rooms/${currentRoom}/players`))
      ]);
      const turn = turnSnap.val();
      const players = Object.keys(playersSnap.val() || {});
      document.querySelectorAll('.player-discard').forEach(slot => {
        const ownerId = slot.dataset.owner;
        const pile = discards[ownerId] || [];
        slot.innerHTML = '';
        if (pile.length) {
          const lastCard = pile[pile.length - 1];
          const cardDiv = createCardElement(lastCard);
          const nextOfOwner = players[(players.indexOf(ownerId) + 1) % players.length];
          if (turn === playerId && playerId === nextOfOwner) {
            cardDiv.classList.add('clickable');
          }
          slot.appendChild(cardDiv);
        } else {
          slot.innerHTML = '<div class="no-card">Pas de carte</div>';
        }
      });
    }

    function listenDiscard(room) {
      onValue(ref(db, `rooms/${room}/discard`), async snap => {
        const discards = snap.val() || {};
        renderDiscardPiles(discards);
      });
    }

    async function handlePickFromPreviousDiscard(ownerId) {
      if (isDrawing) return;
      isDrawing = true;
      try {
        const turn = (await get(ref(db, `rooms/${currentRoom}/turn`))).val();
        if (turn !== playerId) {
          showPopup("Ce n'est pas votre tour.", true);
          return;
        }
        const state = (await get(ref(db, `rooms/${currentRoom}/state`))).val() || {};
        if (state.hasDrawnOrPicked) {
          showPopup("Vous avez dÃ©jÃ  piochÃ©.", true);
          return;
        }
        const players = Object.keys((await get(ref(db, `rooms/${currentRoom}/players`))).val() || {});
        const nextOfOwner = players[(players.indexOf(ownerId) + 1) % players.length];
        if (playerId !== nextOfOwner) {
          showPopup("Vous ne pouvez pas piocher dans cette dÃ©fausse.", true);
          return;
        }
        const discards = (await get(ref(db, `rooms/${currentRoom}/discard`))).val() || {};
        const pile = discards[ownerId] || [];
        if (!pile.length) {
          showPopup("Rien Ã  piocher ici.", true);
          return;
        }
        const card = pile[pile.length - 1];
        const newPile = pile.slice(0, -1);
        const hand = (await get(ref(db, `rooms/${currentRoom}/hands/${playerId}`))).val() || [];
        await Promise.all([
          set(ref(db, `rooms/${currentRoom}/discard/${ownerId}`), newPile),
          set(ref(db, `rooms/${currentRoom}/hands/${playerId}`), [...hand, card]),
          update(ref(db, `rooms/${currentRoom}/state`), { hasDrawnOrPicked: true })
        ]);
      } catch (err) {
        console.error("Erreur lors de la prise depuis la dÃ©fausse :", err);
      } finally {
        isDrawing = false;
      }
    }

    async function sortHandByFormation() {
      const hand = (await get(ref(db, `rooms/${currentRoom}/hands/${playerId}`))).val() || [];
      const jokerCards = (await get(ref(db, `rooms/${currentRoom}/jokerSet`))).val() || [];
      const sorted = [...hand].sort((a, b) => {
        if (a.value !== b.value) return a.value - b.value;
        const suitOrder = ['â™ ', 'â™£', 'â™¦', 'â™¥'];
        return suitOrder.indexOf(a.symbol) - suitOrder.indexOf(b.symbol);
      }).map(c => ({
        ...c,
        isJoker: jokerCards.includes(c.id)
      }));
      await set(ref(db, `rooms/${currentRoom}/hands/${playerId}`), sorted);
    }

    function listenPlayers(room) {
      onValue(ref(db, `rooms/${room}/players`), async snap => {
        const players = Object.entries(snap.val() || {}).map(([id, o]) => {
          playersMap[id] = { pseudo: o.pseudo, totalScore: o.totalScore || 0 };
          return { id, pseudo: o.pseudo, score: o.totalScore || 0 };
        });
        renderPlayers(players);
        const creator = (await get(ref(db, `rooms/${room}/creator`))).val();
        const state = (await get(ref(db, `rooms/${room}/state`))).val() || {};
        const btn = document.getElementById('startGameBtn');
        btn.style.display = (creator === playerId && !state.started) ? 'block' : 'none';
      });
    }

    function renderPlayers(players) {
      const container = document.getElementById('players-container');
      container.innerHTML = '';
      players.forEach((currentPlayer, index) => {
        const prevIndex = (index - 1 + players.length) % players.length;
        const prevPlayer = players[prevIndex];
        const playerDiv = document.createElement('div');
        playerDiv.className = 'player-slot';
        playerDiv.dataset.playerId = currentPlayer.id;
        playerDiv.innerHTML = `
          <div class="player-info ${currentPlayer.id === playerId ? 'active' : ''}">
            <div class="player-name">${currentPlayer.pseudo}</div>
            <div class="player-hand-count">${currentPlayer.score} pts</div>
          </div>
          <div class="player-discard" data-owner="${prevPlayer.id}"></div>
        `;
        container.appendChild(playerDiv);
      });
    }

    function listenHand(room) {
      onValue(ref(db, `rooms/${room}/hands/${playerId}`), snap => {
        const hand = snap.val() || [];
        renderHand(hand);
      });
    }

    function listenTurn(room) {
      onValue(ref(db, `rooms/${room}/turn`), snap => {
        const turn = snap.val();
        const myTurn = turn === playerId;
        hasDrawnOrPicked = false;
        hasDiscardedThisTurn = false;
        document.getElementById('status').textContent = myTurn ? "Votre tour" : "En attente...";
        document.getElementById('endTurnBtn').disabled = !myTurn;
        const btn7N = document.getElementById('declare7N');
        const btnWin = document.getElementById('declareWin');
        if (btn7N) btn7N.disabled = !myTurn;
        if (btnWin) btnWin.disabled = !myTurn;
      });
    }

    function listenJokerCard(room) {
      onValue(ref(db, `rooms/${room}/jokerCard`), snap => {
        const card = snap.val();
        const jokerDiv = document.getElementById('joker');
        if (!jokerDiv) return;
        if (card) {
          jokerDiv.innerHTML = `
            <div class="card ${card.color}">
              <div class="corner top">${card.rank}${card.symbol}</div>
              <div class="suit main">${card.symbol}</div>
            </div>
          `;
        } else {
          jokerDiv.innerHTML = '';
        }
      });
    }

    function enableChat() {
      const chatContainer = document.getElementById('chat-container');
      if (!chatContainer) return;
      const chatHeader = chatContainer.querySelector('.chat-header');
      if (!chatHeader) return;
      chatContainer.classList.remove('collapsed');
      const arrow = chatHeader.querySelector('span');
      if (arrow) arrow.textContent = 'â–¼';
      chatHeader.addEventListener('click', () => {
        chatContainer.classList.toggle('collapsed');
        const arrow = chatHeader.querySelector('span');
        if (arrow) {
          arrow.textContent = chatContainer.classList.contains('collapsed') ? 'â–²' : 'â–¼';
        }
      });
      document.getElementById('chat-form')?.addEventListener('submit', async (e) => {
        e.preventDefault();
        const message = document.getElementById('chat-input')?.value.trim();
        if (!message) return;
        await set(ref(db, `rooms/${currentRoom}/chat/${Date.now()}`), {
          sender: playerId,
          pseudo: myPseudo,
          message,
          timestamp: Date.now()
        });
        document.getElementById('chat-input').value = '';
      });
    }

    function listenChat(room) {
      onValue(ref(db, `rooms/${room}/chat`), (snapshot) => {
        const messages = snapshot.val() || {};
        const messagesArray = Object.entries(messages).map(([id, msg]) => ({ id, ...msg })).sort((a, b) => a.timestamp - b.timestamp);
        const chatMessages = document.getElementById('chat-messages');
        if (!chatMessages) return;
        chatMessages.innerHTML = '';
        messagesArray.forEach(msg => {
          const div = document.createElement('div');
          div.className = `message ${msg.sender === playerId ? 'me' : 'other'}`;
          div.innerHTML = `<b>${msg.pseudo}:</b> ${msg.message}`;
          chatMessages.appendChild(div);
        });
        chatMessages.scrollTop = chatMessages.scrollHeight;
      });
    }

    function setupHandDisplayOptions() {
      const buttons = document.querySelectorAll('.hand-display-btn');
      if (!buttons.length) return;
      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          const displayType = btn.getAttribute('data-display');
          if (displayType) {
            handDisplayType = displayType;
            const hand = document.getElementById('hand');
            if (hand) {
              hand.className = `player-hand ${displayType}`;
            }
          }
        });
      });
    }

    function enableDragDrop() {
      const handElement = document.getElementById('hand');
      if (!handElement) return;
      new Sortable(handElement, {
        animation: 150,
        ghostClass: 'sortable-ghost',
        onEnd: async (evt) => {
          const jokerIds = (await get(ref(db, `rooms/${currentRoom}/jokerSet`))).val() || [];
          const hand = Array.from(handElement.children).map(el => ({
            id: el.dataset.cardId,
            rank: el.dataset.rank,
            symbol: el.dataset.symbol,
            color: el.dataset.color,
            suit: el.dataset.suit,
            value: parseInt(el.dataset.value, 10),
            isJoker: jokerIds.includes(el.dataset.cardId)
          }));
          await set(ref(db, `rooms/${currentRoom}/hands/${playerId}`), hand);
        }
      });
    }

    function showPopup(content, isError = false) {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.cssText = `position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);display:flex;align-items:center;justify-content:center;z-index:9999`;
      modal.innerHTML = `
        <div class="modal-content" style="background:white;padding:2rem;border-radius:12px;max-width:400px;text-align:center;">
          ${content}
          <button class="modal-close" style="margin-top:1rem;padding:.5rem 1rem;background:#3498db;color:white;border:none;border-radius:6px;">OK</button>
        </div>
      `;
      document.body.appendChild(modal);
      modal.querySelector('.modal-close').addEventListener('click', () => modal.remove());
    }

    function showGlobalPopup(message, cards = null) {
      const overlay = document.createElement('div');
      overlay.className = 'global-popup-overlay';
      overlay.innerHTML = `
        <div class="global-popup-box">
          <div class="notif-message">${message}</div>
          ${cards ? '<div class="notif-cards">' + cards.map(c => `
            <div class="card ${c.color}">
              <div class="corner top"><span>${c.rank}</span><span>${c.symbol}</span></div>
              <div class="suit main">${c.symbol}</div>
            </div>
          `).join('') + '</div>' : ''}
        </div>
      `;
      document.body.appendChild(overlay);
      setTimeout(() => overlay.remove(), 10000);
      overlay.addEventListener('click', () => overlay.remove());
    }

    document.getElementById('createRoom').addEventListener('click', createRoom);
    document.getElementById('joinRoom').addEventListener('click', joinRoom);
    document.getElementById('endTurnBtn')?.addEventListener('click', async () => {
      const turn = (await get(ref(db, `rooms/${currentRoom}/turn`))).val();
      if (turn !== playerId) return;
      const state = (await get(ref(db, `rooms/${currentRoom}/state`))).val() || {};
      if (!state.hasDrawnOrPicked || !state.hasDiscardedThisTurn) {
        showPopup("Terminez votre tour (piocher + dÃ©fausser).");
        return;
      }
      const players = Object.keys((await get(ref(db, `rooms/${currentRoom}/players`))).val() || {});
      const nextIndex = (players.indexOf(playerId) + 1) % players.length;
      await Promise.all([
        set(ref(db, `rooms/${currentRoom}/turn`), players[nextIndex]),
        update(ref(db, `rooms/${currentRoom}/state`), {
          hasDrawnOrPicked: false,
          hasDiscardedThisTurn: false,
          drawCount: 0
        })
      ]);
    });
    document.getElementById('declare7N')?.addEventListener('click', declare7Naturel);
    document.getElementById('declareWin')?.addEventListener('click', declareWin);
    document.getElementById('newGameBtn')?.addEventListener('click', startNewGame);

    async function drawCard() {
      if (isDrawing) return;
      isDrawing = true;
      const deckEl = document.getElementById('deck');
      deckEl.classList.add('no-click');
      try {
        const turn = (await get(ref(db, `rooms/${currentRoom}/turn`)).val();
        if (turn !== playerId) throw "Ce n'est pas votre tour.";
        const state = (await get(ref(db, `rooms/${currentRoom}/state`))).val() || {};
        if (state.hasDrawnOrPicked) throw "Vous avez dÃ©jÃ  piochÃ©.";
        const [deckSnap, handSnap] = await Promise.all([
          get(ref(db, `rooms/${currentRoom}/deck`)),
          get(ref(db, `rooms/${currentRoom}/hands/${playerId}`))
        ]);
        const deckCards = deckSnap.val() || [];
        if (!deckCards.length) throw "Deck vide.";
        let card = deckCards.shift();
        const jokerIds = (await get(ref(db, `rooms/${currentRoom}/jokerSet`))).val() || [];
        if (jokerIds.includes(card.id)) {
          card = { ...card, isJoker: true };
        }
        const newHand = [...(handSnap.val() || []), card];
        await Promise.all([
          set(ref(db, `rooms/${currentRoom}/deck`), deckCards),
          set(ref(db, `rooms/${currentRoom}/hands/${playerId}`), newHand),
          update(ref(db, `rooms/${currentRoom}/state`), { hasDrawnOrPicked: true })
        ]);
      } catch (err) {
        if (typeof err === "string") showPopup(err, true);
        else console.error(err);
      } finally {
        isDrawing = false;
        deckEl.classList.remove('no-click');
      }
    }

    async function pickFromDiscard() {
      if (isDrawing) return;
      isDrawing = true;
      const discardEl = document.getElementById('discard');
      discardEl.classList.add('no-click');
      try {
        const turn = (await get(ref(db, `rooms/${currentRoom}/turn`))).val();
        if (turn !== playerId) {
          showPopup("Ce n'est pas votre tour.", true);
          return;
        }
        const state = (await get(ref(db, `rooms/${currentRoom}/state`))).val() || {};
        if (state.hasDrawnOrPicked) {
          showPopup("Vous avez dÃ©jÃ  piochÃ©.", true);
          return;
        }
        const discRef = ref(db, `rooms/${currentRoom}/discard`);
        const snap = await get(discRef);
        const discards = snap.val() || {};
        let ownerId = null, card = null;
        for (let [id, pile] of Object.entries(discards)) {
          if (pile.length && (!card || pile[pile.length - 1].timestamp > card.timestamp)) {
            ownerId = id;
            card = pile[pile.length - 1];
          }
        }
        if (!card) {
          showPopup("Rien Ã  piocher dans la dÃ©fausse.", true);
          return;
        }
        const players = Object.keys((await get(ref(db, `rooms/${currentRoom}/players`))).val() || {});
        const nextOfOwner = players[(players.indexOf(ownerId) + 1) % players.length];
        if (playerId !== nextOfOwner) {
          showPopup("Vous ne pouvez pas piocher dans cette dÃ©fausse.", true);
          return;
        }
        let finalCard = card;
        const jokerIds = (await get(ref(db, `rooms/${currentRoom}/jokerSet`))).val() || [];
        if (jokerIds.includes(card.id)) {
          finalCard = { ...card, isJoker: true };
        }
        const newPile = discards[ownerId].slice(0, -1);
        const hand = (await get(ref(db, `rooms/${currentRoom}/hands/${playerId}`))).val() || [];
        await Promise.all([
          set(ref(db, `rooms/${currentRoom}/discard/${ownerId}`), newPile),
          set(ref(db, `rooms/${currentRoom}/hands/${playerId}`), [...hand, finalCard]),
          update(ref(db, `rooms/${currentRoom}/state`), { hasDrawnOrPicked: true })
        ]);
      } catch (err) {
        console.error(err);
      } finally {
        isDrawing = false;
        discardEl.classList.remove('no-click');
      }
    }

    async function discardCard(cardId) {
      const turn = (await get(ref(db, `rooms/${currentRoom}/turn`))).val();
      if (turn !== playerId) return showPopup("Ce n'est pas votre tour.");
      const state = (await get(ref(db, `rooms/${currentRoom}/state`))).val() || {};
      if (!state.hasDrawnOrPicked) {
        showPopup("Piochez d'abord.");
        return;
      }
      if (state.hasDiscardedThisTurn) {
        showPopup("Vous avez dÃ©jÃ  dÃ©faussÃ©.");
        return;
      }
      const hand = (await get(ref(db, `rooms/${currentRoom}/hands/${playerId}`)).val() || [];
      const cardIndex = hand.findIndex(c => c.id === cardId);
      if (cardIndex === -1) return;
      const [card] = hand.splice(cardIndex, 1);
      const discard = (await get(ref(db, `rooms/${currentRoom}/discard/${playerId}`)).val() || [];
      discard.push(card);
      await Promise.all([
        set(ref(db, `rooms/${currentRoom}/hands/${playerId}`), hand),
        set(ref(db, `rooms/${currentRoom}/discard/${playerId}`), discard),
        update(ref(db, `rooms/${currentRoom}/state`), {
          hasDiscardedThisTurn: true,
          lastDiscardPlayer: playerId,
          lastDiscardCard: card
        })
      ]);
      const players = Object.keys((await get(ref(db, `rooms/${currentRoom}/players`)).val() || {});
      const nextIndex = (players.indexOf(playerId) + 1) % players.length;
      await Promise.all([
        set(ref(db, `rooms/${currentRoom}/turn`), players[nextIndex]),
        update(ref(db, `rooms/${currentRoom}/state`), {
          hasDrawnOrPicked: false,
          hasDiscardedThisTurn: false
        })
      ]);
      renderHand(hand);
    }

    document.getElementById('deck').addEventListener('click', drawCard);
  </script>
</body>
</html>
